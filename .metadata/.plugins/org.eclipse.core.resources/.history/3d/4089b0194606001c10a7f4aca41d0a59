#include "../LIB/BIT_MATH.h"
#include "../LIB/STD_TYPES.h"
#include "../LIB/ATMEGA32_REGISTERS.h"
#include "avr/interrupt.h"
#include "DIO_int.h"
#include "GPT_int.h"

pFunc InternalCBFs[2];

void GPT_vidInit (void)
{
#if GPT_MODE == NORMAL
	TCCR0_REG.Bits.BIT_3 = 0;
	TCCR0_REG.Bits.BIT_6 = 0;
#elif GPT_MODE == CTC
	TCCR0_REG.Bits.BIT_3 = 1;
	TCCR0_REG.Bits.BIT_6 = 0;

	TCCR0_REG.Whole_Register &= OC0_MODE_CLEAR_MASK;
	TCCR0_REG.Whole_Register |= OC0_MODE;

	if(OCR0_VALUE <= 255)
	{
		OCR0_REG.Whole_Register = OCR0_VALUE;
	}
#endif
}


void GPT_vidStopTimer(void)
{
	TCCR0_REG.Whole_Register &= 0xF8;    //0b11111000
}


void GPT_vidStartTimer(void)
{
	TCCR0_REG.Whole_Register &= CS_CLEAR_MASK;
	TCCR0_REG.Whole_Register |= CS_MODE;
}


void GPT_vidLoadTimer(u8 Copy_u8PreloadValue)
{
	TCNT0_REG.Whole_Register = Copy_u8PreloadValue;
}

void GPT_vidEnableNotification(void)
{
#if GPT_MODE == NORMAL
	TIMSK_REG.Bits.BIT_0 = 1;
#elif GPT_MODE == CTC
	TIMSK_REG.Bits.BIT_1 = 1;
#endif
}


void GPT_vidDisableNotification(void)
{
#if GPT_MODE == NORMAL
	TIMSK_REG.Bits.BIT_0 = 0;
#elif GPT_MODE == CTC
	TIMSK_REG.Bits.BIT_1 = 0;
#endif
}


void GPT_vidSetCallBack(pFunc CBF , u8 interruptID)
{
	if(CBF)
	{
		InternalCBFs[interruptID] = CBF;
	}
}


ISR(TIMER0_OVF_vect)
{
	if(InternalCBFs[0])
	{
		InternalCBFs[0]();
	}
}

ISR(TIMER0_COMP_vect)
{
	if(InternalCBFs[1])
	{
		InternalCBFs[1]();
	}
}
