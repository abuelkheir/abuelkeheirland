In archive libPWM_Driver.a:

ADC_pro.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000002a0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000400  00000000  00000000  000002d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.ADC_vidInit 00000054  00000000  00000000  000006d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.ADC_Read 0000007a  00000000  00000000  00000728  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.ADC_vidInit:

00000000 <ADC_vidInit>:
#include "ATMEGA32_REGISTERS.h"
#include "ADC.h"


void ADC_vidInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	//ADC Enable
	ADCSRA_REG.Bits.BIT_7 = 1;
   8:	e6 e2       	ldi	r30, 0x26	; 38
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	80 68       	ori	r24, 0x80	; 128
  10:	80 83       	st	Z, r24

	//Pre-scalar Configurations as 128
	ADCSRA_REG.Bits.BIT_0 = 1;
  12:	e6 e2       	ldi	r30, 0x26	; 38
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	81 60       	ori	r24, 0x01	; 1
  1a:	80 83       	st	Z, r24
	ADCSRA_REG.Bits.BIT_1 = 1;
  1c:	e6 e2       	ldi	r30, 0x26	; 38
  1e:	f0 e0       	ldi	r31, 0x00	; 0
  20:	80 81       	ld	r24, Z
  22:	82 60       	ori	r24, 0x02	; 2
  24:	80 83       	st	Z, r24
	ADCSRA_REG.Bits.BIT_2 = 1;
  26:	e6 e2       	ldi	r30, 0x26	; 38
  28:	f0 e0       	ldi	r31, 0x00	; 0
  2a:	80 81       	ld	r24, Z
  2c:	84 60       	ori	r24, 0x04	; 4
  2e:	80 83       	st	Z, r24

	//Reference voltage as AVCC with external capacitor
	ADMUX_REG.Bits.BIT_6 = 1;
  30:	e7 e2       	ldi	r30, 0x27	; 39
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
  36:	80 64       	ori	r24, 0x40	; 64
  38:	80 83       	st	Z, r24
	ADMUX_REG.Bits.BIT_7 = 0;
  3a:	e7 e2       	ldi	r30, 0x27	; 39
  3c:	f0 e0       	ldi	r31, 0x00	; 0
  3e:	80 81       	ld	r24, Z
  40:	8f 77       	andi	r24, 0x7F	; 127
  42:	80 83       	st	Z, r24

	//ADC Data Right Adjustment
	ADMUX_REG.Bits.BIT_5 = 0;
  44:	e7 e2       	ldi	r30, 0x27	; 39
  46:	f0 e0       	ldi	r31, 0x00	; 0
  48:	80 81       	ld	r24, Z
  4a:	8f 7d       	andi	r24, 0xDF	; 223
  4c:	80 83       	st	Z, r24


}
  4e:	cf 91       	pop	r28
  50:	df 91       	pop	r29
  52:	08 95       	ret

Disassembly of section .text.ADC_Read:

00000000 <ADC_Read>:
#include "ATMEGA32_REGISTERS.h"
#include "ADC.h"


void ADC_vidInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <ADC_Read+0x6>
   6:	0f 92       	push	r0
	//ADC Enable
	ADCSRA_REG.Bits.BIT_7 = 1;
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8b 83       	std	Y+3, r24	; 0x03
   e:	a7 e2       	ldi	r26, 0x27	; 39
  10:	b0 e0       	ldi	r27, 0x00	; 0

	//Pre-scalar Configurations as 128
	ADCSRA_REG.Bits.BIT_0 = 1;
  12:	e7 e2       	ldi	r30, 0x27	; 39
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	80 7e       	andi	r24, 0xE0	; 224
  1a:	8c 93       	st	X, r24
	ADCSRA_REG.Bits.BIT_1 = 1;
  1c:	a7 e2       	ldi	r26, 0x27	; 39
  1e:	b0 e0       	ldi	r27, 0x00	; 0
  20:	e7 e2       	ldi	r30, 0x27	; 39
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	90 81       	ld	r25, Z
	ADCSRA_REG.Bits.BIT_2 = 1;
  26:	8b 81       	ldd	r24, Y+3	; 0x03
  28:	89 2b       	or	r24, r25
  2a:	8c 93       	st	X, r24
  2c:	e6 e2       	ldi	r30, 0x26	; 38
  2e:	f0 e0       	ldi	r31, 0x00	; 0

	//Reference voltage as AVCC with external capacitor
	ADMUX_REG.Bits.BIT_6 = 1;
  30:	80 81       	ld	r24, Z
  32:	80 64       	ori	r24, 0x40	; 64
  34:	80 83       	st	Z, r24
  36:	e6 e2       	ldi	r30, 0x26	; 38
  38:	f0 e0       	ldi	r31, 0x00	; 0
	ADMUX_REG.Bits.BIT_7 = 0;
  3a:	80 81       	ld	r24, Z
  3c:	80 74       	andi	r24, 0x40	; 64
  3e:	88 23       	and	r24, r24
  40:	01 f4       	brne	.+0      	; 0x42 <ADC_Read+0x42>
  42:	e4 e2       	ldi	r30, 0x24	; 36

	//ADC Data Right Adjustment
	ADMUX_REG.Bits.BIT_5 = 0;
  44:	f0 e0       	ldi	r31, 0x00	; 0
  46:	80 81       	ld	r24, Z
  48:	88 2f       	mov	r24, r24
  4a:	90 e0       	ldi	r25, 0x00	; 0
  4c:	9a 83       	std	Y+2, r25	; 0x02


}
  4e:	89 83       	std	Y+1, r24	; 0x01
  50:	e5 e2       	ldi	r30, 0x25	; 37
  52:	f0 e0       	ldi	r31, 0x00	; 0
  54:	80 81       	ld	r24, Z
  56:	88 2f       	mov	r24, r24
  58:	90 e0       	ldi	r25, 0x00	; 0
  5a:	38 2f       	mov	r19, r24
  5c:	22 27       	eor	r18, r18
  5e:	89 81       	ldd	r24, Y+1	; 0x01
  60:	9a 81       	ldd	r25, Y+2	; 0x02
  62:	82 2b       	or	r24, r18
  64:	93 2b       	or	r25, r19
  66:	9a 83       	std	Y+2, r25	; 0x02
  68:	89 83       	std	Y+1, r24	; 0x01
  6a:	89 81       	ldd	r24, Y+1	; 0x01
  6c:	9a 81       	ldd	r25, Y+2	; 0x02
  6e:	0f 90       	pop	r0
  70:	0f 90       	pop	r0
  72:	0f 90       	pop	r0
  74:	cf 91       	pop	r28
  76:	df 91       	pop	r29
  78:	08 95       	ret

DIO_Prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000057c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000577  00000000  00000000  000005b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.DIO_u8GetPin 0000010a  00000000  00000000  00000b27  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.DIO_vidSetPinVal 0000022a  00000000  00000000  00000c31  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.DIO_vidTogglePinVal 000000fc  00000000  00000000  00000e5b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.DIO_vidSetPinDirection 0000022a  00000000  00000000  00000f57  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.DIO_vidSetPortDirection 00000090  00000000  00000000  00001181  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.DIO_vidSetPortVal 00000090  00000000  00000000  00001211  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.DIO_u8GetPin:

00000000 <DIO_u8GetPin>:
#include "ATMEGA32_REGISTERS.H"
#include "DIO_int.h"


u8 DIO_u8GetPin(u8 Copy_PortID ,u8 Copy_PinID )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_u8GetPin+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_u8GetPin+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
	u8 PinLevel;
	if(((Copy_PortID >= PORTA)	 && (Copy_PortID <= PORTD)) && ((Copy_PinID >= DIO_u8PIN_0) && (Copy_PinID <= DIO_u8PIN_7)))
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	88 23       	and	r24, r24
  16:	01 f4       	brne	.+0      	; 0x18 <DIO_u8GetPin+0x18>
  18:	00 c0       	rjmp	.+0      	; 0x1a <DIO_u8GetPin+0x1a>
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	85 30       	cpi	r24, 0x05	; 5
  1e:	00 f0       	brcs	.+0      	; 0x20 <DIO_u8GetPin+0x20>
  20:	00 c0       	rjmp	.+0      	; 0x22 <DIO_u8GetPin+0x22>
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	88 30       	cpi	r24, 0x08	; 8
  26:	00 f0       	brcs	.+0      	; 0x28 <DIO_u8GetPin+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <DIO_u8GetPin+0x2a>
	{

		switch(Copy_PortID)
  2a:	8a 81       	ldd	r24, Y+2	; 0x02
  2c:	28 2f       	mov	r18, r24
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	3d 83       	std	Y+5, r19	; 0x05
  32:	2c 83       	std	Y+4, r18	; 0x04
  34:	4c 81       	ldd	r20, Y+4	; 0x04
  36:	5d 81       	ldd	r21, Y+5	; 0x05
  38:	42 30       	cpi	r20, 0x02	; 2
  3a:	51 05       	cpc	r21, r1
  3c:	01 f0       	breq	.+0      	; 0x3e <DIO_u8GetPin+0x3e>
  3e:	8c 81       	ldd	r24, Y+4	; 0x04
  40:	9d 81       	ldd	r25, Y+5	; 0x05
  42:	83 30       	cpi	r24, 0x03	; 3
  44:	91 05       	cpc	r25, r1
  46:	04 f4       	brge	.+0      	; 0x48 <DIO_u8GetPin+0x48>
  48:	2c 81       	ldd	r18, Y+4	; 0x04
  4a:	3d 81       	ldd	r19, Y+5	; 0x05
  4c:	21 30       	cpi	r18, 0x01	; 1
  4e:	31 05       	cpc	r19, r1
  50:	01 f0       	breq	.+0      	; 0x52 <DIO_u8GetPin+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <DIO_u8GetPin+0x54>
  54:	4c 81       	ldd	r20, Y+4	; 0x04
  56:	5d 81       	ldd	r21, Y+5	; 0x05
  58:	43 30       	cpi	r20, 0x03	; 3
  5a:	51 05       	cpc	r21, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <DIO_u8GetPin+0x5e>
  5e:	8c 81       	ldd	r24, Y+4	; 0x04
  60:	9d 81       	ldd	r25, Y+5	; 0x05
  62:	84 30       	cpi	r24, 0x04	; 4
  64:	91 05       	cpc	r25, r1
  66:	01 f0       	breq	.+0      	; 0x68 <DIO_u8GetPin+0x68>
  68:	00 c0       	rjmp	.+0      	; 0x6a <DIO_u8GetPin+0x6a>
		{
		case PORTA:
			PinLevel = GET_BIT(PINA_REG,Copy_PinID);
  6a:	e9 e3       	ldi	r30, 0x39	; 57
  6c:	f0 e0       	ldi	r31, 0x00	; 0
  6e:	80 81       	ld	r24, Z
  70:	28 2f       	mov	r18, r24
  72:	30 e0       	ldi	r19, 0x00	; 0
  74:	8b 81       	ldd	r24, Y+3	; 0x03
  76:	88 2f       	mov	r24, r24
  78:	90 e0       	ldi	r25, 0x00	; 0
  7a:	a9 01       	movw	r20, r18
  7c:	00 c0       	rjmp	.+0      	; 0x7e <DIO_u8GetPin+0x7e>
  7e:	55 95       	asr	r21
  80:	47 95       	ror	r20
  82:	8a 95       	dec	r24
  84:	02 f4       	brpl	.+0      	; 0x86 <DIO_u8GetPin+0x86>
  86:	ca 01       	movw	r24, r20
  88:	81 70       	andi	r24, 0x01	; 1
  8a:	89 83       	std	Y+1, r24	; 0x01
  8c:	00 c0       	rjmp	.+0      	; 0x8e <DIO_u8GetPin+0x8e>
			break;
		case PORTB:
			PinLevel = GET_BIT(PINB_REG,Copy_PinID);
  8e:	e6 e3       	ldi	r30, 0x36	; 54
  90:	f0 e0       	ldi	r31, 0x00	; 0
  92:	80 81       	ld	r24, Z
  94:	28 2f       	mov	r18, r24
  96:	30 e0       	ldi	r19, 0x00	; 0
  98:	8b 81       	ldd	r24, Y+3	; 0x03
  9a:	88 2f       	mov	r24, r24
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	a9 01       	movw	r20, r18
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <DIO_u8GetPin+0xa2>
  a2:	55 95       	asr	r21
  a4:	47 95       	ror	r20
  a6:	8a 95       	dec	r24
  a8:	02 f4       	brpl	.+0      	; 0xaa <DIO_u8GetPin+0xaa>
  aa:	ca 01       	movw	r24, r20
  ac:	81 70       	andi	r24, 0x01	; 1
  ae:	89 83       	std	Y+1, r24	; 0x01
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <DIO_u8GetPin+0xb2>
			break;
		case PORTC:
			PinLevel = GET_BIT(PINC_REG,Copy_PinID);
  b2:	e3 e3       	ldi	r30, 0x33	; 51
  b4:	f0 e0       	ldi	r31, 0x00	; 0
  b6:	80 81       	ld	r24, Z
  b8:	28 2f       	mov	r18, r24
  ba:	30 e0       	ldi	r19, 0x00	; 0
  bc:	8b 81       	ldd	r24, Y+3	; 0x03
  be:	88 2f       	mov	r24, r24
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	a9 01       	movw	r20, r18
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <DIO_u8GetPin+0xc6>
  c6:	55 95       	asr	r21
  c8:	47 95       	ror	r20
  ca:	8a 95       	dec	r24
  cc:	02 f4       	brpl	.+0      	; 0xce <DIO_u8GetPin+0xce>
  ce:	ca 01       	movw	r24, r20
  d0:	81 70       	andi	r24, 0x01	; 1
  d2:	89 83       	std	Y+1, r24	; 0x01
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <DIO_u8GetPin+0xd6>
			break;
		case PORTD:
			PinLevel = GET_BIT(PIND_REG,Copy_PinID);
  d6:	e0 e3       	ldi	r30, 0x30	; 48
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	80 81       	ld	r24, Z
  dc:	28 2f       	mov	r18, r24
  de:	30 e0       	ldi	r19, 0x00	; 0
  e0:	8b 81       	ldd	r24, Y+3	; 0x03
  e2:	88 2f       	mov	r24, r24
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	a9 01       	movw	r20, r18
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_u8GetPin+0xea>
  ea:	55 95       	asr	r21
  ec:	47 95       	ror	r20
  ee:	8a 95       	dec	r24
  f0:	02 f4       	brpl	.+0      	; 0xf2 <DIO_u8GetPin+0xf2>
  f2:	ca 01       	movw	r24, r20
  f4:	81 70       	andi	r24, 0x01	; 1
  f6:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}
	return PinLevel;
  f8:	89 81       	ldd	r24, Y+1	; 0x01
}
  fa:	0f 90       	pop	r0
  fc:	0f 90       	pop	r0
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
 102:	0f 90       	pop	r0
 104:	cf 91       	pop	r28
 106:	df 91       	pop	r29
 108:	08 95       	ret

Disassembly of section .text.DIO_vidSetPinVal:

00000000 <DIO_vidSetPinVal>:
#include "ATMEGA32_REGISTERS.H"
#include "DIO_int.h"


u8 DIO_u8GetPin(u8 Copy_PortID ,u8 Copy_PinID )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	u8 PinLevel;
	if(((Copy_PortID >= PORTA)	 && (Copy_PortID <= PORTD)) && ((Copy_PinID >= DIO_u8PIN_0) && (Copy_PinID <= DIO_u8PIN_7)))
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 83       	std	Y+1, r24	; 0x01
  16:	6a 83       	std	Y+2, r22	; 0x02
  18:	4b 83       	std	Y+3, r20	; 0x03
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	88 23       	and	r24, r24
  1e:	01 f4       	brne	.+0      	; 0x20 <DIO_vidSetPinVal+0x20>
  20:	00 c0       	rjmp	.+0      	; 0x22 <DIO_vidSetPinVal+0x22>
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	85 30       	cpi	r24, 0x05	; 5
  26:	00 f0       	brcs	.+0      	; 0x28 <DIO_vidSetPinVal+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <DIO_vidSetPinVal+0x2a>
	{

		switch(Copy_PortID)
  2a:	8a 81       	ldd	r24, Y+2	; 0x02
  2c:	88 30       	cpi	r24, 0x08	; 8
  2e:	00 f0       	brcs	.+0      	; 0x30 <DIO_vidSetPinVal+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <DIO_vidSetPinVal+0x32>
  32:	8b 81       	ldd	r24, Y+3	; 0x03
  34:	81 30       	cpi	r24, 0x01	; 1
  36:	01 f0       	breq	.+0      	; 0x38 <DIO_vidSetPinVal+0x38>
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	88 23       	and	r24, r24
  3c:	01 f0       	breq	.+0      	; 0x3e <DIO_vidSetPinVal+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <DIO_vidSetPinVal+0x40>
  40:	8b 81       	ldd	r24, Y+3	; 0x03
  42:	81 30       	cpi	r24, 0x01	; 1
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_vidSetPinVal+0x46>
  46:	00 c0       	rjmp	.+0      	; 0x48 <DIO_vidSetPinVal+0x48>
  48:	89 81       	ldd	r24, Y+1	; 0x01
  4a:	28 2f       	mov	r18, r24
  4c:	30 e0       	ldi	r19, 0x00	; 0
  4e:	3f 83       	std	Y+7, r19	; 0x07
  50:	2e 83       	std	Y+6, r18	; 0x06
  52:	8e 81       	ldd	r24, Y+6	; 0x06
  54:	9f 81       	ldd	r25, Y+7	; 0x07
  56:	82 30       	cpi	r24, 0x02	; 2
  58:	91 05       	cpc	r25, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <DIO_vidSetPinVal+0x5c>
  5c:	2e 81       	ldd	r18, Y+6	; 0x06
  5e:	3f 81       	ldd	r19, Y+7	; 0x07
  60:	23 30       	cpi	r18, 0x03	; 3
  62:	31 05       	cpc	r19, r1
  64:	04 f4       	brge	.+0      	; 0x66 <DIO_vidSetPinVal+0x66>
  66:	8e 81       	ldd	r24, Y+6	; 0x06
  68:	9f 81       	ldd	r25, Y+7	; 0x07
		{
		case PORTA:
			PinLevel = GET_BIT(PINA_REG,Copy_PinID);
  6a:	81 30       	cpi	r24, 0x01	; 1
  6c:	91 05       	cpc	r25, r1
  6e:	01 f0       	breq	.+0      	; 0x70 <DIO_vidSetPinVal+0x70>
  70:	00 c0       	rjmp	.+0      	; 0x72 <DIO_vidSetPinVal+0x72>
  72:	2e 81       	ldd	r18, Y+6	; 0x06
  74:	3f 81       	ldd	r19, Y+7	; 0x07
  76:	23 30       	cpi	r18, 0x03	; 3
  78:	31 05       	cpc	r19, r1
  7a:	01 f0       	breq	.+0      	; 0x7c <DIO_vidSetPinVal+0x7c>
  7c:	8e 81       	ldd	r24, Y+6	; 0x06
  7e:	9f 81       	ldd	r25, Y+7	; 0x07
  80:	84 30       	cpi	r24, 0x04	; 4
  82:	91 05       	cpc	r25, r1
  84:	01 f0       	breq	.+0      	; 0x86 <DIO_vidSetPinVal+0x86>
  86:	00 c0       	rjmp	.+0      	; 0x88 <DIO_vidSetPinVal+0x88>
  88:	ab e3       	ldi	r26, 0x3B	; 59
  8a:	b0 e0       	ldi	r27, 0x00	; 0
  8c:	eb e3       	ldi	r30, 0x3B	; 59
			break;
		case PORTB:
			PinLevel = GET_BIT(PINB_REG,Copy_PinID);
  8e:	f0 e0       	ldi	r31, 0x00	; 0
  90:	80 81       	ld	r24, Z
  92:	48 2f       	mov	r20, r24
  94:	8a 81       	ldd	r24, Y+2	; 0x02
  96:	28 2f       	mov	r18, r24
  98:	30 e0       	ldi	r19, 0x00	; 0
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	02 2e       	mov	r0, r18
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <DIO_vidSetPinVal+0xa2>
  a2:	88 0f       	add	r24, r24
  a4:	99 1f       	adc	r25, r25
  a6:	0a 94       	dec	r0
  a8:	02 f4       	brpl	.+0      	; 0xaa <DIO_vidSetPinVal+0xaa>
  aa:	84 2b       	or	r24, r20
  ac:	8c 93       	st	X, r24
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <DIO_vidSetPinVal+0xb0>
  b0:	a8 e3       	ldi	r26, 0x38	; 56
			break;
		case PORTC:
			PinLevel = GET_BIT(PINC_REG,Copy_PinID);
  b2:	b0 e0       	ldi	r27, 0x00	; 0
  b4:	e8 e3       	ldi	r30, 0x38	; 56
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	80 81       	ld	r24, Z
  ba:	48 2f       	mov	r20, r24
  bc:	8a 81       	ldd	r24, Y+2	; 0x02
  be:	28 2f       	mov	r18, r24
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	81 e0       	ldi	r24, 0x01	; 1
  c4:	90 e0       	ldi	r25, 0x00	; 0
  c6:	02 2e       	mov	r0, r18
  c8:	00 c0       	rjmp	.+0      	; 0xca <DIO_vidSetPinVal+0xca>
  ca:	88 0f       	add	r24, r24
  cc:	99 1f       	adc	r25, r25
  ce:	0a 94       	dec	r0
  d0:	02 f4       	brpl	.+0      	; 0xd2 <DIO_vidSetPinVal+0xd2>
  d2:	84 2b       	or	r24, r20
  d4:	8c 93       	st	X, r24
			break;
		case PORTD:
			PinLevel = GET_BIT(PIND_REG,Copy_PinID);
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <DIO_vidSetPinVal+0xd8>
  d8:	a5 e3       	ldi	r26, 0x35	; 53
  da:	b0 e0       	ldi	r27, 0x00	; 0
  dc:	e5 e3       	ldi	r30, 0x35	; 53
  de:	f0 e0       	ldi	r31, 0x00	; 0
  e0:	80 81       	ld	r24, Z
  e2:	48 2f       	mov	r20, r24
  e4:	8a 81       	ldd	r24, Y+2	; 0x02
  e6:	28 2f       	mov	r18, r24
  e8:	30 e0       	ldi	r19, 0x00	; 0
  ea:	81 e0       	ldi	r24, 0x01	; 1
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	02 2e       	mov	r0, r18
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <DIO_vidSetPinVal+0xf2>
  f2:	88 0f       	add	r24, r24
  f4:	99 1f       	adc	r25, r25
  f6:	0a 94       	dec	r0
			break;
		}
	}
	return PinLevel;
  f8:	02 f4       	brpl	.+0      	; 0xfa <DIO_vidSetPinVal+0xfa>
}
  fa:	84 2b       	or	r24, r20
  fc:	8c 93       	st	X, r24
  fe:	00 c0       	rjmp	.+0      	; 0x100 <DIO_vidSetPinVal+0x100>
 100:	a2 e3       	ldi	r26, 0x32	; 50
 102:	b0 e0       	ldi	r27, 0x00	; 0
 104:	e2 e3       	ldi	r30, 0x32	; 50
 106:	f0 e0       	ldi	r31, 0x00	; 0
 108:	80 81       	ld	r24, Z
 10a:	48 2f       	mov	r20, r24
 10c:	8a 81       	ldd	r24, Y+2	; 0x02
 10e:	28 2f       	mov	r18, r24
 110:	30 e0       	ldi	r19, 0x00	; 0
 112:	81 e0       	ldi	r24, 0x01	; 1
 114:	90 e0       	ldi	r25, 0x00	; 0
 116:	02 2e       	mov	r0, r18
 118:	00 c0       	rjmp	.+0      	; 0x11a <DIO_vidSetPinVal+0x11a>
 11a:	88 0f       	add	r24, r24
 11c:	99 1f       	adc	r25, r25
 11e:	0a 94       	dec	r0
 120:	02 f4       	brpl	.+0      	; 0x122 <DIO_vidSetPinVal+0x122>
 122:	84 2b       	or	r24, r20
 124:	8c 93       	st	X, r24
 126:	00 c0       	rjmp	.+0      	; 0x128 <DIO_vidSetPinVal+0x128>
 128:	8b 81       	ldd	r24, Y+3	; 0x03
 12a:	88 23       	and	r24, r24
 12c:	01 f0       	breq	.+0      	; 0x12e <DIO_vidSetPinVal+0x12e>
 12e:	00 c0       	rjmp	.+0      	; 0x130 <DIO_vidSetPinVal+0x130>
 130:	89 81       	ldd	r24, Y+1	; 0x01
 132:	28 2f       	mov	r18, r24
 134:	30 e0       	ldi	r19, 0x00	; 0
 136:	3d 83       	std	Y+5, r19	; 0x05
 138:	2c 83       	std	Y+4, r18	; 0x04
 13a:	8c 81       	ldd	r24, Y+4	; 0x04
 13c:	9d 81       	ldd	r25, Y+5	; 0x05
 13e:	82 30       	cpi	r24, 0x02	; 2
 140:	91 05       	cpc	r25, r1
 142:	01 f0       	breq	.+0      	; 0x144 <DIO_vidSetPinVal+0x144>
 144:	2c 81       	ldd	r18, Y+4	; 0x04
 146:	3d 81       	ldd	r19, Y+5	; 0x05
 148:	23 30       	cpi	r18, 0x03	; 3
 14a:	31 05       	cpc	r19, r1
 14c:	04 f4       	brge	.+0      	; 0x14e <DIO_vidSetPinVal+0x14e>
 14e:	8c 81       	ldd	r24, Y+4	; 0x04
 150:	9d 81       	ldd	r25, Y+5	; 0x05
 152:	81 30       	cpi	r24, 0x01	; 1
 154:	91 05       	cpc	r25, r1
 156:	01 f0       	breq	.+0      	; 0x158 <DIO_vidSetPinVal+0x158>
 158:	00 c0       	rjmp	.+0      	; 0x15a <DIO_vidSetPinVal+0x15a>
 15a:	2c 81       	ldd	r18, Y+4	; 0x04
 15c:	3d 81       	ldd	r19, Y+5	; 0x05
 15e:	23 30       	cpi	r18, 0x03	; 3
 160:	31 05       	cpc	r19, r1
 162:	01 f0       	breq	.+0      	; 0x164 <DIO_vidSetPinVal+0x164>
 164:	8c 81       	ldd	r24, Y+4	; 0x04
 166:	9d 81       	ldd	r25, Y+5	; 0x05
 168:	84 30       	cpi	r24, 0x04	; 4
 16a:	91 05       	cpc	r25, r1
 16c:	01 f4       	brne	.+0      	; 0x16e <DIO_vidSetPinVal+0x16e>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <DIO_vidSetPinVal+0x170>
 170:	00 c0       	rjmp	.+0      	; 0x172 <DIO_vidSetPinVal+0x172>
 172:	ab e3       	ldi	r26, 0x3B	; 59
 174:	b0 e0       	ldi	r27, 0x00	; 0
 176:	eb e3       	ldi	r30, 0x3B	; 59
 178:	f0 e0       	ldi	r31, 0x00	; 0
 17a:	80 81       	ld	r24, Z
 17c:	48 2f       	mov	r20, r24
 17e:	8a 81       	ldd	r24, Y+2	; 0x02
 180:	28 2f       	mov	r18, r24
 182:	30 e0       	ldi	r19, 0x00	; 0
 184:	81 e0       	ldi	r24, 0x01	; 1
 186:	90 e0       	ldi	r25, 0x00	; 0
 188:	02 2e       	mov	r0, r18
 18a:	00 c0       	rjmp	.+0      	; 0x18c <DIO_vidSetPinVal+0x18c>
 18c:	88 0f       	add	r24, r24
 18e:	99 1f       	adc	r25, r25
 190:	0a 94       	dec	r0
 192:	02 f4       	brpl	.+0      	; 0x194 <DIO_vidSetPinVal+0x194>
 194:	80 95       	com	r24
 196:	84 23       	and	r24, r20
 198:	8c 93       	st	X, r24
 19a:	00 c0       	rjmp	.+0      	; 0x19c <DIO_vidSetPinVal+0x19c>
 19c:	a8 e3       	ldi	r26, 0x38	; 56
 19e:	b0 e0       	ldi	r27, 0x00	; 0
 1a0:	e8 e3       	ldi	r30, 0x38	; 56
 1a2:	f0 e0       	ldi	r31, 0x00	; 0
 1a4:	80 81       	ld	r24, Z
 1a6:	48 2f       	mov	r20, r24
 1a8:	8a 81       	ldd	r24, Y+2	; 0x02
 1aa:	28 2f       	mov	r18, r24
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	81 e0       	ldi	r24, 0x01	; 1
 1b0:	90 e0       	ldi	r25, 0x00	; 0
 1b2:	02 2e       	mov	r0, r18
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <DIO_vidSetPinVal+0x1b6>
 1b6:	88 0f       	add	r24, r24
 1b8:	99 1f       	adc	r25, r25
 1ba:	0a 94       	dec	r0
 1bc:	02 f4       	brpl	.+0      	; 0x1be <DIO_vidSetPinVal+0x1be>
 1be:	80 95       	com	r24
 1c0:	84 23       	and	r24, r20
 1c2:	8c 93       	st	X, r24
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <DIO_vidSetPinVal+0x1c6>
 1c6:	a5 e3       	ldi	r26, 0x35	; 53
 1c8:	b0 e0       	ldi	r27, 0x00	; 0
 1ca:	e5 e3       	ldi	r30, 0x35	; 53
 1cc:	f0 e0       	ldi	r31, 0x00	; 0
 1ce:	80 81       	ld	r24, Z
 1d0:	48 2f       	mov	r20, r24
 1d2:	8a 81       	ldd	r24, Y+2	; 0x02
 1d4:	28 2f       	mov	r18, r24
 1d6:	30 e0       	ldi	r19, 0x00	; 0
 1d8:	81 e0       	ldi	r24, 0x01	; 1
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	02 2e       	mov	r0, r18
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <DIO_vidSetPinVal+0x1e0>
 1e0:	88 0f       	add	r24, r24
 1e2:	99 1f       	adc	r25, r25
 1e4:	0a 94       	dec	r0
 1e6:	02 f4       	brpl	.+0      	; 0x1e8 <DIO_vidSetPinVal+0x1e8>
 1e8:	80 95       	com	r24
 1ea:	84 23       	and	r24, r20
 1ec:	8c 93       	st	X, r24
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <DIO_vidSetPinVal+0x1f0>
 1f0:	a2 e3       	ldi	r26, 0x32	; 50
 1f2:	b0 e0       	ldi	r27, 0x00	; 0
 1f4:	e2 e3       	ldi	r30, 0x32	; 50
 1f6:	f0 e0       	ldi	r31, 0x00	; 0
 1f8:	80 81       	ld	r24, Z
 1fa:	48 2f       	mov	r20, r24
 1fc:	8a 81       	ldd	r24, Y+2	; 0x02
 1fe:	28 2f       	mov	r18, r24
 200:	30 e0       	ldi	r19, 0x00	; 0
 202:	81 e0       	ldi	r24, 0x01	; 1
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	02 2e       	mov	r0, r18
 208:	00 c0       	rjmp	.+0      	; 0x20a <DIO_vidSetPinVal+0x20a>
 20a:	88 0f       	add	r24, r24
 20c:	99 1f       	adc	r25, r25
 20e:	0a 94       	dec	r0
 210:	02 f4       	brpl	.+0      	; 0x212 <DIO_vidSetPinVal+0x212>
 212:	80 95       	com	r24
 214:	84 23       	and	r24, r20
 216:	8c 93       	st	X, r24
 218:	27 96       	adiw	r28, 0x07	; 7
 21a:	0f b6       	in	r0, 0x3f	; 63
 21c:	f8 94       	cli
 21e:	de bf       	out	0x3e, r29	; 62
 220:	0f be       	out	0x3f, r0	; 63
 222:	cd bf       	out	0x3d, r28	; 61
 224:	cf 91       	pop	r28
 226:	df 91       	pop	r29
 228:	08 95       	ret

Disassembly of section .text.DIO_vidTogglePinVal:

00000000 <DIO_vidTogglePinVal>:
#include "ATMEGA32_REGISTERS.H"
#include "DIO_int.h"


u8 DIO_u8GetPin(u8 Copy_PortID ,u8 Copy_PinID )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_vidTogglePinVal+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_vidTogglePinVal+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
	u8 PinLevel;
	if(((Copy_PortID >= PORTA)	 && (Copy_PortID <= PORTD)) && ((Copy_PinID >= DIO_u8PIN_0) && (Copy_PinID <= DIO_u8PIN_7)))
  12:	28 2f       	mov	r18, r24
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	82 30       	cpi	r24, 0x02	; 2
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <DIO_vidTogglePinVal+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	23 30       	cpi	r18, 0x03	; 3
	{

		switch(Copy_PortID)
  2a:	31 05       	cpc	r19, r1
  2c:	04 f4       	brge	.+0      	; 0x2e <DIO_vidTogglePinVal+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	91 05       	cpc	r25, r1
  36:	01 f0       	breq	.+0      	; 0x38 <DIO_vidTogglePinVal+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <DIO_vidTogglePinVal+0x3a>
  3a:	2b 81       	ldd	r18, Y+3	; 0x03
  3c:	3c 81       	ldd	r19, Y+4	; 0x04
  3e:	23 30       	cpi	r18, 0x03	; 3
  40:	31 05       	cpc	r19, r1
  42:	01 f0       	breq	.+0      	; 0x44 <DIO_vidTogglePinVal+0x44>
  44:	8b 81       	ldd	r24, Y+3	; 0x03
  46:	9c 81       	ldd	r25, Y+4	; 0x04
  48:	84 30       	cpi	r24, 0x04	; 4
  4a:	91 05       	cpc	r25, r1
  4c:	01 f0       	breq	.+0      	; 0x4e <DIO_vidTogglePinVal+0x4e>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <DIO_vidTogglePinVal+0x50>
  50:	ab e3       	ldi	r26, 0x3B	; 59
  52:	b0 e0       	ldi	r27, 0x00	; 0
  54:	eb e3       	ldi	r30, 0x3B	; 59
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	80 81       	ld	r24, Z
  5a:	48 2f       	mov	r20, r24
  5c:	8a 81       	ldd	r24, Y+2	; 0x02
  5e:	28 2f       	mov	r18, r24
  60:	30 e0       	ldi	r19, 0x00	; 0
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	90 e0       	ldi	r25, 0x00	; 0
  66:	02 2e       	mov	r0, r18
  68:	00 c0       	rjmp	.+0      	; 0x6a <DIO_vidTogglePinVal+0x6a>
		{
		case PORTA:
			PinLevel = GET_BIT(PINA_REG,Copy_PinID);
  6a:	88 0f       	add	r24, r24
  6c:	99 1f       	adc	r25, r25
  6e:	0a 94       	dec	r0
  70:	02 f4       	brpl	.+0      	; 0x72 <DIO_vidTogglePinVal+0x72>
  72:	84 27       	eor	r24, r20
  74:	8c 93       	st	X, r24
  76:	00 c0       	rjmp	.+0      	; 0x78 <DIO_vidTogglePinVal+0x78>
  78:	a8 e3       	ldi	r26, 0x38	; 56
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	e8 e3       	ldi	r30, 0x38	; 56
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	80 81       	ld	r24, Z
  82:	48 2f       	mov	r20, r24
  84:	8a 81       	ldd	r24, Y+2	; 0x02
  86:	28 2f       	mov	r18, r24
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	81 e0       	ldi	r24, 0x01	; 1
  8c:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case PORTB:
			PinLevel = GET_BIT(PINB_REG,Copy_PinID);
  8e:	02 2e       	mov	r0, r18
  90:	00 c0       	rjmp	.+0      	; 0x92 <DIO_vidTogglePinVal+0x92>
  92:	88 0f       	add	r24, r24
  94:	99 1f       	adc	r25, r25
  96:	0a 94       	dec	r0
  98:	02 f4       	brpl	.+0      	; 0x9a <DIO_vidTogglePinVal+0x9a>
  9a:	84 27       	eor	r24, r20
  9c:	8c 93       	st	X, r24
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <DIO_vidTogglePinVal+0xa0>
  a0:	a5 e3       	ldi	r26, 0x35	; 53
  a2:	b0 e0       	ldi	r27, 0x00	; 0
  a4:	e5 e3       	ldi	r30, 0x35	; 53
  a6:	f0 e0       	ldi	r31, 0x00	; 0
  a8:	80 81       	ld	r24, Z
  aa:	48 2f       	mov	r20, r24
  ac:	8a 81       	ldd	r24, Y+2	; 0x02
  ae:	28 2f       	mov	r18, r24
  b0:	30 e0       	ldi	r19, 0x00	; 0
			break;
		case PORTC:
			PinLevel = GET_BIT(PINC_REG,Copy_PinID);
  b2:	81 e0       	ldi	r24, 0x01	; 1
  b4:	90 e0       	ldi	r25, 0x00	; 0
  b6:	02 2e       	mov	r0, r18
  b8:	00 c0       	rjmp	.+0      	; 0xba <DIO_vidTogglePinVal+0xba>
  ba:	88 0f       	add	r24, r24
  bc:	99 1f       	adc	r25, r25
  be:	0a 94       	dec	r0
  c0:	02 f4       	brpl	.+0      	; 0xc2 <DIO_vidTogglePinVal+0xc2>
  c2:	84 27       	eor	r24, r20
  c4:	8c 93       	st	X, r24
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <DIO_vidTogglePinVal+0xc8>
  c8:	a2 e3       	ldi	r26, 0x32	; 50
  ca:	b0 e0       	ldi	r27, 0x00	; 0
  cc:	e2 e3       	ldi	r30, 0x32	; 50
  ce:	f0 e0       	ldi	r31, 0x00	; 0
  d0:	80 81       	ld	r24, Z
  d2:	48 2f       	mov	r20, r24
  d4:	8a 81       	ldd	r24, Y+2	; 0x02
			break;
		case PORTD:
			PinLevel = GET_BIT(PIND_REG,Copy_PinID);
  d6:	28 2f       	mov	r18, r24
  d8:	30 e0       	ldi	r19, 0x00	; 0
  da:	81 e0       	ldi	r24, 0x01	; 1
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	02 2e       	mov	r0, r18
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <DIO_vidTogglePinVal+0xe2>
  e2:	88 0f       	add	r24, r24
  e4:	99 1f       	adc	r25, r25
  e6:	0a 94       	dec	r0
  e8:	02 f4       	brpl	.+0      	; 0xea <DIO_vidTogglePinVal+0xea>
  ea:	84 27       	eor	r24, r20
  ec:	8c 93       	st	X, r24
  ee:	0f 90       	pop	r0
  f0:	0f 90       	pop	r0
  f2:	0f 90       	pop	r0
  f4:	0f 90       	pop	r0
  f6:	cf 91       	pop	r28
			break;
		}
	}
	return PinLevel;
  f8:	df 91       	pop	r29
}
  fa:	08 95       	ret

Disassembly of section .text.DIO_vidSetPinDirection:

00000000 <DIO_vidSetPinDirection>:
#include "ATMEGA32_REGISTERS.H"
#include "DIO_int.h"


u8 DIO_u8GetPin(u8 Copy_PortID ,u8 Copy_PinID )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	u8 PinLevel;
	if(((Copy_PortID >= PORTA)	 && (Copy_PortID <= PORTD)) && ((Copy_PinID >= DIO_u8PIN_0) && (Copy_PinID <= DIO_u8PIN_7)))
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 83       	std	Y+1, r24	; 0x01
  16:	6a 83       	std	Y+2, r22	; 0x02
  18:	4b 83       	std	Y+3, r20	; 0x03
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	88 23       	and	r24, r24
  1e:	01 f4       	brne	.+0      	; 0x20 <DIO_vidSetPinDirection+0x20>
  20:	00 c0       	rjmp	.+0      	; 0x22 <DIO_vidSetPinDirection+0x22>
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	85 30       	cpi	r24, 0x05	; 5
  26:	00 f0       	brcs	.+0      	; 0x28 <DIO_vidSetPinDirection+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <DIO_vidSetPinDirection+0x2a>
	{

		switch(Copy_PortID)
  2a:	8a 81       	ldd	r24, Y+2	; 0x02
  2c:	88 30       	cpi	r24, 0x08	; 8
  2e:	00 f0       	brcs	.+0      	; 0x30 <DIO_vidSetPinDirection+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <DIO_vidSetPinDirection+0x32>
  32:	8b 81       	ldd	r24, Y+3	; 0x03
  34:	88 23       	and	r24, r24
  36:	01 f0       	breq	.+0      	; 0x38 <DIO_vidSetPinDirection+0x38>
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	01 f0       	breq	.+0      	; 0x3e <DIO_vidSetPinDirection+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <DIO_vidSetPinDirection+0x40>
  40:	8b 81       	ldd	r24, Y+3	; 0x03
  42:	88 23       	and	r24, r24
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_vidSetPinDirection+0x46>
  46:	00 c0       	rjmp	.+0      	; 0x48 <DIO_vidSetPinDirection+0x48>
  48:	89 81       	ldd	r24, Y+1	; 0x01
  4a:	28 2f       	mov	r18, r24
  4c:	30 e0       	ldi	r19, 0x00	; 0
  4e:	3f 83       	std	Y+7, r19	; 0x07
  50:	2e 83       	std	Y+6, r18	; 0x06
  52:	8e 81       	ldd	r24, Y+6	; 0x06
  54:	9f 81       	ldd	r25, Y+7	; 0x07
  56:	82 30       	cpi	r24, 0x02	; 2
  58:	91 05       	cpc	r25, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <DIO_vidSetPinDirection+0x5c>
  5c:	2e 81       	ldd	r18, Y+6	; 0x06
  5e:	3f 81       	ldd	r19, Y+7	; 0x07
  60:	23 30       	cpi	r18, 0x03	; 3
  62:	31 05       	cpc	r19, r1
  64:	04 f4       	brge	.+0      	; 0x66 <DIO_vidSetPinDirection+0x66>
  66:	8e 81       	ldd	r24, Y+6	; 0x06
  68:	9f 81       	ldd	r25, Y+7	; 0x07
		{
		case PORTA:
			PinLevel = GET_BIT(PINA_REG,Copy_PinID);
  6a:	81 30       	cpi	r24, 0x01	; 1
  6c:	91 05       	cpc	r25, r1
  6e:	01 f0       	breq	.+0      	; 0x70 <DIO_vidSetPinDirection+0x70>
  70:	00 c0       	rjmp	.+0      	; 0x72 <DIO_vidSetPinDirection+0x72>
  72:	2e 81       	ldd	r18, Y+6	; 0x06
  74:	3f 81       	ldd	r19, Y+7	; 0x07
  76:	23 30       	cpi	r18, 0x03	; 3
  78:	31 05       	cpc	r19, r1
  7a:	01 f0       	breq	.+0      	; 0x7c <DIO_vidSetPinDirection+0x7c>
  7c:	8e 81       	ldd	r24, Y+6	; 0x06
  7e:	9f 81       	ldd	r25, Y+7	; 0x07
  80:	84 30       	cpi	r24, 0x04	; 4
  82:	91 05       	cpc	r25, r1
  84:	01 f4       	brne	.+0      	; 0x86 <DIO_vidSetPinDirection+0x86>
  86:	00 c0       	rjmp	.+0      	; 0x88 <DIO_vidSetPinDirection+0x88>
  88:	00 c0       	rjmp	.+0      	; 0x8a <DIO_vidSetPinDirection+0x8a>
  8a:	aa e3       	ldi	r26, 0x3A	; 58
  8c:	b0 e0       	ldi	r27, 0x00	; 0
			break;
		case PORTB:
			PinLevel = GET_BIT(PINB_REG,Copy_PinID);
  8e:	ea e3       	ldi	r30, 0x3A	; 58
  90:	f0 e0       	ldi	r31, 0x00	; 0
  92:	80 81       	ld	r24, Z
  94:	48 2f       	mov	r20, r24
  96:	8a 81       	ldd	r24, Y+2	; 0x02
  98:	28 2f       	mov	r18, r24
  9a:	30 e0       	ldi	r19, 0x00	; 0
  9c:	81 e0       	ldi	r24, 0x01	; 1
  9e:	90 e0       	ldi	r25, 0x00	; 0
  a0:	02 2e       	mov	r0, r18
  a2:	00 c0       	rjmp	.+0      	; 0xa4 <DIO_vidSetPinDirection+0xa4>
  a4:	88 0f       	add	r24, r24
  a6:	99 1f       	adc	r25, r25
  a8:	0a 94       	dec	r0
  aa:	02 f4       	brpl	.+0      	; 0xac <DIO_vidSetPinDirection+0xac>
  ac:	80 95       	com	r24
  ae:	84 23       	and	r24, r20
  b0:	8c 93       	st	X, r24
			break;
		case PORTC:
			PinLevel = GET_BIT(PINC_REG,Copy_PinID);
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <DIO_vidSetPinDirection+0xb4>
  b4:	a7 e3       	ldi	r26, 0x37	; 55
  b6:	b0 e0       	ldi	r27, 0x00	; 0
  b8:	e7 e3       	ldi	r30, 0x37	; 55
  ba:	f0 e0       	ldi	r31, 0x00	; 0
  bc:	80 81       	ld	r24, Z
  be:	48 2f       	mov	r20, r24
  c0:	8a 81       	ldd	r24, Y+2	; 0x02
  c2:	28 2f       	mov	r18, r24
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	90 e0       	ldi	r25, 0x00	; 0
  ca:	02 2e       	mov	r0, r18
  cc:	00 c0       	rjmp	.+0      	; 0xce <DIO_vidSetPinDirection+0xce>
  ce:	88 0f       	add	r24, r24
  d0:	99 1f       	adc	r25, r25
  d2:	0a 94       	dec	r0
  d4:	02 f4       	brpl	.+0      	; 0xd6 <DIO_vidSetPinDirection+0xd6>
			break;
		case PORTD:
			PinLevel = GET_BIT(PIND_REG,Copy_PinID);
  d6:	80 95       	com	r24
  d8:	84 23       	and	r24, r20
  da:	8c 93       	st	X, r24
  dc:	00 c0       	rjmp	.+0      	; 0xde <DIO_vidSetPinDirection+0xde>
  de:	a4 e3       	ldi	r26, 0x34	; 52
  e0:	b0 e0       	ldi	r27, 0x00	; 0
  e2:	e4 e3       	ldi	r30, 0x34	; 52
  e4:	f0 e0       	ldi	r31, 0x00	; 0
  e6:	80 81       	ld	r24, Z
  e8:	48 2f       	mov	r20, r24
  ea:	8a 81       	ldd	r24, Y+2	; 0x02
  ec:	28 2f       	mov	r18, r24
  ee:	30 e0       	ldi	r19, 0x00	; 0
  f0:	81 e0       	ldi	r24, 0x01	; 1
  f2:	90 e0       	ldi	r25, 0x00	; 0
  f4:	02 2e       	mov	r0, r18
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <DIO_vidSetPinDirection+0xf8>
			break;
		}
	}
	return PinLevel;
  f8:	88 0f       	add	r24, r24
}
  fa:	99 1f       	adc	r25, r25
  fc:	0a 94       	dec	r0
  fe:	02 f4       	brpl	.+0      	; 0x100 <DIO_vidSetPinDirection+0x100>
 100:	80 95       	com	r24
 102:	84 23       	and	r24, r20
 104:	8c 93       	st	X, r24
 106:	00 c0       	rjmp	.+0      	; 0x108 <DIO_vidSetPinDirection+0x108>
 108:	a1 e3       	ldi	r26, 0x31	; 49
 10a:	b0 e0       	ldi	r27, 0x00	; 0
 10c:	e1 e3       	ldi	r30, 0x31	; 49
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	80 81       	ld	r24, Z
 112:	48 2f       	mov	r20, r24
 114:	8a 81       	ldd	r24, Y+2	; 0x02
 116:	28 2f       	mov	r18, r24
 118:	30 e0       	ldi	r19, 0x00	; 0
 11a:	81 e0       	ldi	r24, 0x01	; 1
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	02 2e       	mov	r0, r18
 120:	00 c0       	rjmp	.+0      	; 0x122 <DIO_vidSetPinDirection+0x122>
 122:	88 0f       	add	r24, r24
 124:	99 1f       	adc	r25, r25
 126:	0a 94       	dec	r0
 128:	02 f4       	brpl	.+0      	; 0x12a <DIO_vidSetPinDirection+0x12a>
 12a:	80 95       	com	r24
 12c:	84 23       	and	r24, r20
 12e:	8c 93       	st	X, r24
 130:	00 c0       	rjmp	.+0      	; 0x132 <DIO_vidSetPinDirection+0x132>
 132:	8b 81       	ldd	r24, Y+3	; 0x03
 134:	81 30       	cpi	r24, 0x01	; 1
 136:	01 f0       	breq	.+0      	; 0x138 <DIO_vidSetPinDirection+0x138>
 138:	00 c0       	rjmp	.+0      	; 0x13a <DIO_vidSetPinDirection+0x13a>
 13a:	89 81       	ldd	r24, Y+1	; 0x01
 13c:	28 2f       	mov	r18, r24
 13e:	30 e0       	ldi	r19, 0x00	; 0
 140:	3d 83       	std	Y+5, r19	; 0x05
 142:	2c 83       	std	Y+4, r18	; 0x04
 144:	8c 81       	ldd	r24, Y+4	; 0x04
 146:	9d 81       	ldd	r25, Y+5	; 0x05
 148:	82 30       	cpi	r24, 0x02	; 2
 14a:	91 05       	cpc	r25, r1
 14c:	01 f0       	breq	.+0      	; 0x14e <DIO_vidSetPinDirection+0x14e>
 14e:	2c 81       	ldd	r18, Y+4	; 0x04
 150:	3d 81       	ldd	r19, Y+5	; 0x05
 152:	23 30       	cpi	r18, 0x03	; 3
 154:	31 05       	cpc	r19, r1
 156:	04 f4       	brge	.+0      	; 0x158 <DIO_vidSetPinDirection+0x158>
 158:	8c 81       	ldd	r24, Y+4	; 0x04
 15a:	9d 81       	ldd	r25, Y+5	; 0x05
 15c:	81 30       	cpi	r24, 0x01	; 1
 15e:	91 05       	cpc	r25, r1
 160:	01 f0       	breq	.+0      	; 0x162 <DIO_vidSetPinDirection+0x162>
 162:	00 c0       	rjmp	.+0      	; 0x164 <DIO_vidSetPinDirection+0x164>
 164:	2c 81       	ldd	r18, Y+4	; 0x04
 166:	3d 81       	ldd	r19, Y+5	; 0x05
 168:	23 30       	cpi	r18, 0x03	; 3
 16a:	31 05       	cpc	r19, r1
 16c:	01 f0       	breq	.+0      	; 0x16e <DIO_vidSetPinDirection+0x16e>
 16e:	8c 81       	ldd	r24, Y+4	; 0x04
 170:	9d 81       	ldd	r25, Y+5	; 0x05
 172:	84 30       	cpi	r24, 0x04	; 4
 174:	91 05       	cpc	r25, r1
 176:	01 f0       	breq	.+0      	; 0x178 <DIO_vidSetPinDirection+0x178>
 178:	00 c0       	rjmp	.+0      	; 0x17a <DIO_vidSetPinDirection+0x17a>
 17a:	aa e3       	ldi	r26, 0x3A	; 58
 17c:	b0 e0       	ldi	r27, 0x00	; 0
 17e:	ea e3       	ldi	r30, 0x3A	; 58
 180:	f0 e0       	ldi	r31, 0x00	; 0
 182:	80 81       	ld	r24, Z
 184:	48 2f       	mov	r20, r24
 186:	8a 81       	ldd	r24, Y+2	; 0x02
 188:	28 2f       	mov	r18, r24
 18a:	30 e0       	ldi	r19, 0x00	; 0
 18c:	81 e0       	ldi	r24, 0x01	; 1
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	02 2e       	mov	r0, r18
 192:	00 c0       	rjmp	.+0      	; 0x194 <DIO_vidSetPinDirection+0x194>
 194:	88 0f       	add	r24, r24
 196:	99 1f       	adc	r25, r25
 198:	0a 94       	dec	r0
 19a:	02 f4       	brpl	.+0      	; 0x19c <DIO_vidSetPinDirection+0x19c>
 19c:	84 2b       	or	r24, r20
 19e:	8c 93       	st	X, r24
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <DIO_vidSetPinDirection+0x1a2>
 1a2:	a7 e3       	ldi	r26, 0x37	; 55
 1a4:	b0 e0       	ldi	r27, 0x00	; 0
 1a6:	e7 e3       	ldi	r30, 0x37	; 55
 1a8:	f0 e0       	ldi	r31, 0x00	; 0
 1aa:	80 81       	ld	r24, Z
 1ac:	48 2f       	mov	r20, r24
 1ae:	8a 81       	ldd	r24, Y+2	; 0x02
 1b0:	28 2f       	mov	r18, r24
 1b2:	30 e0       	ldi	r19, 0x00	; 0
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	02 2e       	mov	r0, r18
 1ba:	00 c0       	rjmp	.+0      	; 0x1bc <DIO_vidSetPinDirection+0x1bc>
 1bc:	88 0f       	add	r24, r24
 1be:	99 1f       	adc	r25, r25
 1c0:	0a 94       	dec	r0
 1c2:	02 f4       	brpl	.+0      	; 0x1c4 <DIO_vidSetPinDirection+0x1c4>
 1c4:	84 2b       	or	r24, r20
 1c6:	8c 93       	st	X, r24
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <DIO_vidSetPinDirection+0x1ca>
 1ca:	a4 e3       	ldi	r26, 0x34	; 52
 1cc:	b0 e0       	ldi	r27, 0x00	; 0
 1ce:	e4 e3       	ldi	r30, 0x34	; 52
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	80 81       	ld	r24, Z
 1d4:	48 2f       	mov	r20, r24
 1d6:	8a 81       	ldd	r24, Y+2	; 0x02
 1d8:	28 2f       	mov	r18, r24
 1da:	30 e0       	ldi	r19, 0x00	; 0
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	90 e0       	ldi	r25, 0x00	; 0
 1e0:	02 2e       	mov	r0, r18
 1e2:	00 c0       	rjmp	.+0      	; 0x1e4 <DIO_vidSetPinDirection+0x1e4>
 1e4:	88 0f       	add	r24, r24
 1e6:	99 1f       	adc	r25, r25
 1e8:	0a 94       	dec	r0
 1ea:	02 f4       	brpl	.+0      	; 0x1ec <DIO_vidSetPinDirection+0x1ec>
 1ec:	84 2b       	or	r24, r20
 1ee:	8c 93       	st	X, r24
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <DIO_vidSetPinDirection+0x1f2>
 1f2:	a1 e3       	ldi	r26, 0x31	; 49
 1f4:	b0 e0       	ldi	r27, 0x00	; 0
 1f6:	e1 e3       	ldi	r30, 0x31	; 49
 1f8:	f0 e0       	ldi	r31, 0x00	; 0
 1fa:	80 81       	ld	r24, Z
 1fc:	48 2f       	mov	r20, r24
 1fe:	8a 81       	ldd	r24, Y+2	; 0x02
 200:	28 2f       	mov	r18, r24
 202:	30 e0       	ldi	r19, 0x00	; 0
 204:	81 e0       	ldi	r24, 0x01	; 1
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	02 2e       	mov	r0, r18
 20a:	00 c0       	rjmp	.+0      	; 0x20c <DIO_vidSetPinDirection+0x20c>
 20c:	88 0f       	add	r24, r24
 20e:	99 1f       	adc	r25, r25
 210:	0a 94       	dec	r0
 212:	02 f4       	brpl	.+0      	; 0x214 <DIO_vidSetPinDirection+0x214>
 214:	84 2b       	or	r24, r20
 216:	8c 93       	st	X, r24
 218:	27 96       	adiw	r28, 0x07	; 7
 21a:	0f b6       	in	r0, 0x3f	; 63
 21c:	f8 94       	cli
 21e:	de bf       	out	0x3e, r29	; 62
 220:	0f be       	out	0x3f, r0	; 63
 222:	cd bf       	out	0x3d, r28	; 61
 224:	cf 91       	pop	r28
 226:	df 91       	pop	r29
 228:	08 95       	ret

Disassembly of section .text.DIO_vidSetPortDirection:

00000000 <DIO_vidSetPortDirection>:
#include "ATMEGA32_REGISTERS.H"
#include "DIO_int.h"


u8 DIO_u8GetPin(u8 Copy_PortID ,u8 Copy_PinID )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_vidSetPortDirection+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_vidSetPortDirection+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
	u8 PinLevel;
	if(((Copy_PortID >= PORTA)	 && (Copy_PortID <= PORTD)) && ((Copy_PinID >= DIO_u8PIN_0) && (Copy_PinID <= DIO_u8PIN_7)))
  12:	88 23       	and	r24, r24
  14:	01 f0       	breq	.+0      	; 0x16 <DIO_vidSetPortDirection+0x16>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	85 30       	cpi	r24, 0x05	; 5
  1a:	00 f4       	brcc	.+0      	; 0x1c <DIO_vidSetPortDirection+0x1c>
  1c:	89 81       	ldd	r24, Y+1	; 0x01
  1e:	28 2f       	mov	r18, r24
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	3c 83       	std	Y+4, r19	; 0x04
  24:	2b 83       	std	Y+3, r18	; 0x03
  26:	8b 81       	ldd	r24, Y+3	; 0x03
  28:	9c 81       	ldd	r25, Y+4	; 0x04
	{

		switch(Copy_PortID)
  2a:	82 30       	cpi	r24, 0x02	; 2
  2c:	91 05       	cpc	r25, r1
  2e:	01 f0       	breq	.+0      	; 0x30 <DIO_vidSetPortDirection+0x30>
  30:	2b 81       	ldd	r18, Y+3	; 0x03
  32:	3c 81       	ldd	r19, Y+4	; 0x04
  34:	23 30       	cpi	r18, 0x03	; 3
  36:	31 05       	cpc	r19, r1
  38:	04 f4       	brge	.+0      	; 0x3a <DIO_vidSetPortDirection+0x3a>
  3a:	8b 81       	ldd	r24, Y+3	; 0x03
  3c:	9c 81       	ldd	r25, Y+4	; 0x04
  3e:	81 30       	cpi	r24, 0x01	; 1
  40:	91 05       	cpc	r25, r1
  42:	01 f0       	breq	.+0      	; 0x44 <DIO_vidSetPortDirection+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <DIO_vidSetPortDirection+0x46>
  46:	2b 81       	ldd	r18, Y+3	; 0x03
  48:	3c 81       	ldd	r19, Y+4	; 0x04
  4a:	23 30       	cpi	r18, 0x03	; 3
  4c:	31 05       	cpc	r19, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_vidSetPortDirection+0x50>
  50:	8b 81       	ldd	r24, Y+3	; 0x03
  52:	9c 81       	ldd	r25, Y+4	; 0x04
  54:	84 30       	cpi	r24, 0x04	; 4
  56:	91 05       	cpc	r25, r1
  58:	01 f0       	breq	.+0      	; 0x5a <DIO_vidSetPortDirection+0x5a>
  5a:	00 c0       	rjmp	.+0      	; 0x5c <DIO_vidSetPortDirection+0x5c>
  5c:	ea e3       	ldi	r30, 0x3A	; 58
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	8a 81       	ldd	r24, Y+2	; 0x02
  62:	80 83       	st	Z, r24
  64:	00 c0       	rjmp	.+0      	; 0x66 <DIO_vidSetPortDirection+0x66>
  66:	e7 e3       	ldi	r30, 0x37	; 55
  68:	f0 e0       	ldi	r31, 0x00	; 0
		{
		case PORTA:
			PinLevel = GET_BIT(PINA_REG,Copy_PinID);
  6a:	8a 81       	ldd	r24, Y+2	; 0x02
  6c:	80 83       	st	Z, r24
  6e:	00 c0       	rjmp	.+0      	; 0x70 <DIO_vidSetPortDirection+0x70>
  70:	e4 e3       	ldi	r30, 0x34	; 52
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	8a 81       	ldd	r24, Y+2	; 0x02
  76:	80 83       	st	Z, r24
  78:	00 c0       	rjmp	.+0      	; 0x7a <DIO_vidSetPortDirection+0x7a>
  7a:	e1 e3       	ldi	r30, 0x31	; 49
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	8a 81       	ldd	r24, Y+2	; 0x02
  80:	80 83       	st	Z, r24
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	cf 91       	pop	r28
  8c:	df 91       	pop	r29
			break;
		case PORTB:
			PinLevel = GET_BIT(PINB_REG,Copy_PinID);
  8e:	08 95       	ret

Disassembly of section .text.DIO_vidSetPortVal:

00000000 <DIO_vidSetPortVal>:
#include "ATMEGA32_REGISTERS.H"
#include "DIO_int.h"


u8 DIO_u8GetPin(u8 Copy_PortID ,u8 Copy_PinID )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_vidSetPortVal+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_vidSetPortVal+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
	u8 PinLevel;
	if(((Copy_PortID >= PORTA)	 && (Copy_PortID <= PORTD)) && ((Copy_PinID >= DIO_u8PIN_0) && (Copy_PinID <= DIO_u8PIN_7)))
  12:	88 23       	and	r24, r24
  14:	01 f0       	breq	.+0      	; 0x16 <DIO_vidSetPortVal+0x16>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	85 30       	cpi	r24, 0x05	; 5
  1a:	00 f4       	brcc	.+0      	; 0x1c <DIO_vidSetPortVal+0x1c>
  1c:	89 81       	ldd	r24, Y+1	; 0x01
  1e:	28 2f       	mov	r18, r24
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	3c 83       	std	Y+4, r19	; 0x04
  24:	2b 83       	std	Y+3, r18	; 0x03
  26:	8b 81       	ldd	r24, Y+3	; 0x03
  28:	9c 81       	ldd	r25, Y+4	; 0x04
	{

		switch(Copy_PortID)
  2a:	82 30       	cpi	r24, 0x02	; 2
  2c:	91 05       	cpc	r25, r1
  2e:	01 f0       	breq	.+0      	; 0x30 <DIO_vidSetPortVal+0x30>
  30:	2b 81       	ldd	r18, Y+3	; 0x03
  32:	3c 81       	ldd	r19, Y+4	; 0x04
  34:	23 30       	cpi	r18, 0x03	; 3
  36:	31 05       	cpc	r19, r1
  38:	04 f4       	brge	.+0      	; 0x3a <DIO_vidSetPortVal+0x3a>
  3a:	8b 81       	ldd	r24, Y+3	; 0x03
  3c:	9c 81       	ldd	r25, Y+4	; 0x04
  3e:	81 30       	cpi	r24, 0x01	; 1
  40:	91 05       	cpc	r25, r1
  42:	01 f0       	breq	.+0      	; 0x44 <DIO_vidSetPortVal+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <DIO_vidSetPortVal+0x46>
  46:	2b 81       	ldd	r18, Y+3	; 0x03
  48:	3c 81       	ldd	r19, Y+4	; 0x04
  4a:	23 30       	cpi	r18, 0x03	; 3
  4c:	31 05       	cpc	r19, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_vidSetPortVal+0x50>
  50:	8b 81       	ldd	r24, Y+3	; 0x03
  52:	9c 81       	ldd	r25, Y+4	; 0x04
  54:	84 30       	cpi	r24, 0x04	; 4
  56:	91 05       	cpc	r25, r1
  58:	01 f0       	breq	.+0      	; 0x5a <DIO_vidSetPortVal+0x5a>
  5a:	00 c0       	rjmp	.+0      	; 0x5c <DIO_vidSetPortVal+0x5c>
  5c:	eb e3       	ldi	r30, 0x3B	; 59
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	8a 81       	ldd	r24, Y+2	; 0x02
  62:	80 83       	st	Z, r24
  64:	00 c0       	rjmp	.+0      	; 0x66 <DIO_vidSetPortVal+0x66>
  66:	e8 e3       	ldi	r30, 0x38	; 56
  68:	f0 e0       	ldi	r31, 0x00	; 0
		{
		case PORTA:
			PinLevel = GET_BIT(PINA_REG,Copy_PinID);
  6a:	8a 81       	ldd	r24, Y+2	; 0x02
  6c:	80 83       	st	Z, r24
  6e:	00 c0       	rjmp	.+0      	; 0x70 <DIO_vidSetPortVal+0x70>
  70:	e5 e3       	ldi	r30, 0x35	; 53
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	8a 81       	ldd	r24, Y+2	; 0x02
  76:	80 83       	st	Z, r24
  78:	00 c0       	rjmp	.+0      	; 0x7a <DIO_vidSetPortVal+0x7a>
  7a:	e2 e3       	ldi	r30, 0x32	; 50
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	8a 81       	ldd	r24, Y+2	; 0x02
  80:	80 83       	st	Z, r24
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	cf 91       	pop	r28
  8c:	df 91       	pop	r29
			break;
		case PORTB:
			PinLevel = GET_BIT(PINB_REG,Copy_PinID);
  8e:	08 95       	ret

GPT_prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005a0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000a2b  00000000  00000000  000005d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.GPT_vidInit 00000022  00000000  00000000  00000fff  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.GPT_vidStopTimer 0000001c  00000000  00000000  00001021  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.GPT_vidStartTimer 0000002a  00000000  00000000  0000103d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.GPT_vidLoadTimer 0000001c  00000000  00000000  00001067  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.GPT_vidEnableNotification 00000018  00000000  00000000  00001083  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.GPT_vidDisableNotification 00000018  00000000  00000000  0000109b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.GPT_vidSetCallBack 0000003e  00000000  00000000  000010b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.__vector_11 00000066  00000000  00000000  000010f1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.__vector_10 00000066  00000000  00000000  00001157  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.GPT_vidInit:

00000000 <GPT_vidInit>:
		InternalCBFs[0](); //calling function
	}
}

ISR(TIMER0_COMP_vect) //ISR for output compare match
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e3 e5       	ldi	r30, 0x53	; 83
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	87 7f       	andi	r24, 0xF7	; 247
  10:	80 83       	st	Z, r24
  12:	e3 e5       	ldi	r30, 0x53	; 83
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	8f 7b       	andi	r24, 0xBF	; 191
  1a:	80 83       	st	Z, r24
  1c:	cf 91       	pop	r28
  1e:	df 91       	pop	r29
  20:	08 95       	ret

Disassembly of section .text.GPT_vidStopTimer:

00000000 <GPT_vidStopTimer>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a3 e5       	ldi	r26, 0x53	; 83
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e3 e5       	ldi	r30, 0x53	; 83
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	88 7f       	andi	r24, 0xF8	; 248
  14:	8c 93       	st	X, r24
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.GPT_vidStartTimer:

00000000 <GPT_vidStartTimer>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a3 e5       	ldi	r26, 0x53	; 83
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e3 e5       	ldi	r30, 0x53	; 83
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	88 7f       	andi	r24, 0xF8	; 248
  14:	8c 93       	st	X, r24
  16:	a3 e5       	ldi	r26, 0x53	; 83
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	e3 e5       	ldi	r30, 0x53	; 83
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	82 60       	ori	r24, 0x02	; 2
  22:	8c 93       	st	X, r24
  24:	cf 91       	pop	r28
  26:	df 91       	pop	r29
  28:	08 95       	ret

Disassembly of section .text.GPT_vidLoadTimer:

00000000 <GPT_vidLoadTimer>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	e2 e5       	ldi	r30, 0x52	; 82
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	80 83       	st	Z, r24
  14:	0f 90       	pop	r0
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.GPT_vidEnableNotification:

00000000 <GPT_vidEnableNotification>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e9 e5       	ldi	r30, 0x59	; 89
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	81 60       	ori	r24, 0x01	; 1
  10:	80 83       	st	Z, r24
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.GPT_vidDisableNotification:

00000000 <GPT_vidDisableNotification>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e9 e5       	ldi	r30, 0x59	; 89
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	8e 7f       	andi	r24, 0xFE	; 254
  10:	80 83       	st	Z, r24
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.GPT_vidSetCallBack:

00000000 <GPT_vidSetCallBack>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPT_vidSetCallBack+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	89 81       	ldd	r24, Y+1	; 0x01
  14:	9a 81       	ldd	r25, Y+2	; 0x02
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f0       	breq	.+0      	; 0x1a <GPT_vidSetCallBack+0x1a>
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	88 2f       	mov	r24, r24
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	88 0f       	add	r24, r24
  22:	99 1f       	adc	r25, r25
  24:	fc 01       	movw	r30, r24
  26:	e0 50       	subi	r30, 0x00	; 0
  28:	f0 40       	sbci	r31, 0x00	; 0
	if(InternalCBFs[1]) //checks if InternalCBF of element 0 is not empty
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	9a 81       	ldd	r25, Y+2	; 0x02
  2e:	91 83       	std	Z+1, r25	; 0x01
  30:	80 83       	st	Z, r24
  32:	0f 90       	pop	r0
  34:	0f 90       	pop	r0
	{
		InternalCBFs[1](); //calling function
  36:	0f 90       	pop	r0
  38:	cf 91       	pop	r28
  3a:	df 91       	pop	r29
  3c:	08 95       	ret

Disassembly of section .text.__vector_11:

00000000 <__vector_11>:
		InternalCBFs[0](); //calling function
	}
}

ISR(TIMER0_COMP_vect) //ISR for output compare match
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	if(InternalCBFs[1]) //checks if InternalCBF of element 0 is not empty
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_11+0x36>
	{
		InternalCBFs[1](); //calling function
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
	}
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_10:

00000000 <__vector_10>:
		InternalCBFs[0](); //calling function
	}
}

ISR(TIMER0_COMP_vect) //ISR for output compare match
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	if(InternalCBFs[1]) //checks if InternalCBF of element 0 is not empty
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_10+0x36>
	{
		InternalCBFs[1](); //calling function
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
	}
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

LCD_Prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000009d8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001132  00000000  00000000  00000a0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.LCD_vidWriteData 00000150  00000000  00000000  00001b3e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.LCD_vidSendCommand 00000150  00000000  00000000  00001c8e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.LCD_vidWriteString 00000056  00000000  00000000  00001dde  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.LCD_vidInit 0000040a  00000000  00000000  00001e34  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.LCD_vidGoTo 00000054  00000000  00000000  0000223e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.LCD_vidWriteData:

00000000 <LCD_vidWriteData>:
#include "DIO_int.h"
#include "LCD_int.h"
#include "ATMEGA32_REGISTERS.h"

void LCD_vidWriteData(u8 Copy_Data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2f 97       	sbiw	r28, 0x0f	; 15
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_5,DIO_u8HIGH);
  16:	eb e3       	ldi	r30, 0x3B	; 59
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	65 e0       	ldi	r22, 0x05	; 5
  1e:	41 e0       	ldi	r20, 0x01	; 1
  20:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_6,DIO_u8LOW);
  24:	eb e3       	ldi	r30, 0x3B	; 59
  26:	f0 e0       	ldi	r31, 0x00	; 0
  28:	80 81       	ld	r24, Z
  2a:	66 e0       	ldi	r22, 0x06	; 6
  2c:	40 e0       	ldi	r20, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
	DIO_vidSetPortVal(PORTB_REG,Copy_Data);
  32:	e8 e3       	ldi	r30, 0x38	; 56
  34:	f0 e0       	ldi	r31, 0x00	; 0
  36:	80 81       	ld	r24, Z
  38:	6f 85       	ldd	r22, Y+15	; 0x0f
  3a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8HIGH);
  3e:	eb e3       	ldi	r30, 0x3B	; 59
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	80 81       	ld	r24, Z
  44:	67 e0       	ldi	r22, 0x07	; 7
  46:	41 e0       	ldi	r20, 0x01	; 1
  48:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	90 e0       	ldi	r25, 0x00	; 0
  50:	a0 e0       	ldi	r26, 0x00	; 0
  52:	b0 e4       	ldi	r27, 0x40	; 64
  54:	8b 87       	std	Y+11, r24	; 0x0b
  56:	9c 87       	std	Y+12, r25	; 0x0c
  58:	ad 87       	std	Y+13, r26	; 0x0d
  5a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  5c:	6b 85       	ldd	r22, Y+11	; 0x0b
  5e:	7c 85       	ldd	r23, Y+12	; 0x0c
  60:	8d 85       	ldd	r24, Y+13	; 0x0d
  62:	9e 85       	ldd	r25, Y+14	; 0x0e
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	30 e0       	ldi	r19, 0x00	; 0
  68:	4a ef       	ldi	r20, 0xFA	; 250
  6a:	54 e4       	ldi	r21, 0x44	; 68
  6c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
  70:	dc 01       	movw	r26, r24
  72:	cb 01       	movw	r24, r22
  74:	8f 83       	std	Y+7, r24	; 0x07
  76:	98 87       	std	Y+8, r25	; 0x08
  78:	a9 87       	std	Y+9, r26	; 0x09
  7a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
  7c:	6f 81       	ldd	r22, Y+7	; 0x07
  7e:	78 85       	ldd	r23, Y+8	; 0x08
  80:	89 85       	ldd	r24, Y+9	; 0x09
  82:	9a 85       	ldd	r25, Y+10	; 0x0a
  84:	20 e0       	ldi	r18, 0x00	; 0
  86:	30 e0       	ldi	r19, 0x00	; 0
  88:	40 e8       	ldi	r20, 0x80	; 128
  8a:	5f e3       	ldi	r21, 0x3F	; 63
  8c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
  90:	88 23       	and	r24, r24
  92:	04 f4       	brge	.+0      	; 0x94 <LCD_vidWriteData+0x94>
		__ticks = 1;
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	9e 83       	std	Y+6, r25	; 0x06
  9a:	8d 83       	std	Y+5, r24	; 0x05
  9c:	00 c0       	rjmp	.+0      	; 0x9e <LCD_vidWriteData+0x9e>
	else if (__tmp > 65535)
  9e:	6f 81       	ldd	r22, Y+7	; 0x07
  a0:	78 85       	ldd	r23, Y+8	; 0x08
  a2:	89 85       	ldd	r24, Y+9	; 0x09
  a4:	9a 85       	ldd	r25, Y+10	; 0x0a
  a6:	20 e0       	ldi	r18, 0x00	; 0
  a8:	3f ef       	ldi	r19, 0xFF	; 255
  aa:	4f e7       	ldi	r20, 0x7F	; 127
  ac:	57 e4       	ldi	r21, 0x47	; 71
  ae:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
  b2:	18 16       	cp	r1, r24
  b4:	04 f4       	brge	.+0      	; 0xb6 <LCD_vidWriteData+0xb6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  b6:	6b 85       	ldd	r22, Y+11	; 0x0b
  b8:	7c 85       	ldd	r23, Y+12	; 0x0c
  ba:	8d 85       	ldd	r24, Y+13	; 0x0d
  bc:	9e 85       	ldd	r25, Y+14	; 0x0e
  be:	20 e0       	ldi	r18, 0x00	; 0
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	40 e2       	ldi	r20, 0x20	; 32
  c4:	51 e4       	ldi	r21, 0x41	; 65
  c6:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
  ca:	dc 01       	movw	r26, r24
  cc:	cb 01       	movw	r24, r22
  ce:	bc 01       	movw	r22, r24
  d0:	cd 01       	movw	r24, r26
  d2:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
  d6:	dc 01       	movw	r26, r24
  d8:	cb 01       	movw	r24, r22
  da:	9e 83       	std	Y+6, r25	; 0x06
  dc:	8d 83       	std	Y+5, r24	; 0x05
  de:	00 c0       	rjmp	.+0      	; 0xe0 <LCD_vidWriteData+0xe0>
  e0:	88 ec       	ldi	r24, 0xC8	; 200
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	9c 83       	std	Y+4, r25	; 0x04
  e6:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  e8:	8b 81       	ldd	r24, Y+3	; 0x03
  ea:	9c 81       	ldd	r25, Y+4	; 0x04
  ec:	01 97       	sbiw	r24, 0x01	; 1
  ee:	01 f4       	brne	.+0      	; 0xf0 <LCD_vidWriteData+0xf0>
  f0:	9c 83       	std	Y+4, r25	; 0x04
  f2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  f4:	8d 81       	ldd	r24, Y+5	; 0x05
  f6:	9e 81       	ldd	r25, Y+6	; 0x06
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	9e 83       	std	Y+6, r25	; 0x06
  fc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  fe:	8d 81       	ldd	r24, Y+5	; 0x05
 100:	9e 81       	ldd	r25, Y+6	; 0x06
 102:	00 97       	sbiw	r24, 0x00	; 0
 104:	01 f4       	brne	.+0      	; 0x106 <LCD_vidWriteData+0x106>
 106:	00 c0       	rjmp	.+0      	; 0x108 <LCD_vidWriteData+0x108>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 108:	6f 81       	ldd	r22, Y+7	; 0x07
 10a:	78 85       	ldd	r23, Y+8	; 0x08
 10c:	89 85       	ldd	r24, Y+9	; 0x09
 10e:	9a 85       	ldd	r25, Y+10	; 0x0a
 110:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
 114:	dc 01       	movw	r26, r24
 116:	cb 01       	movw	r24, r22
 118:	9e 83       	std	Y+6, r25	; 0x06
 11a:	8d 83       	std	Y+5, r24	; 0x05
 11c:	8d 81       	ldd	r24, Y+5	; 0x05
 11e:	9e 81       	ldd	r25, Y+6	; 0x06
 120:	9a 83       	std	Y+2, r25	; 0x02
 122:	89 83       	std	Y+1, r24	; 0x01
 124:	89 81       	ldd	r24, Y+1	; 0x01
 126:	9a 81       	ldd	r25, Y+2	; 0x02
 128:	01 97       	sbiw	r24, 0x01	; 1
 12a:	01 f4       	brne	.+0      	; 0x12c <LCD_vidWriteData+0x12c>
 12c:	9a 83       	std	Y+2, r25	; 0x02
 12e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8LOW);
 130:	eb e3       	ldi	r30, 0x3B	; 59
 132:	f0 e0       	ldi	r31, 0x00	; 0
 134:	80 81       	ld	r24, Z
 136:	67 e0       	ldi	r22, 0x07	; 7
 138:	40 e0       	ldi	r20, 0x00	; 0
 13a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteData>
}
 13e:	2f 96       	adiw	r28, 0x0f	; 15
 140:	0f b6       	in	r0, 0x3f	; 63
 142:	f8 94       	cli
 144:	de bf       	out	0x3e, r29	; 62
 146:	0f be       	out	0x3f, r0	; 63
 148:	cd bf       	out	0x3d, r28	; 61
 14a:	cf 91       	pop	r28
 14c:	df 91       	pop	r29
 14e:	08 95       	ret

Disassembly of section .text.LCD_vidSendCommand:

00000000 <LCD_vidSendCommand>:
#include "DIO_int.h"
#include "LCD_int.h"
#include "ATMEGA32_REGISTERS.h"

void LCD_vidWriteData(u8 Copy_Data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2f 97       	sbiw	r28, 0x0f	; 15
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_5,DIO_u8HIGH);
  16:	eb e3       	ldi	r30, 0x3B	; 59
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	65 e0       	ldi	r22, 0x05	; 5
  1e:	40 e0       	ldi	r20, 0x00	; 0
  20:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_6,DIO_u8LOW);
  24:	eb e3       	ldi	r30, 0x3B	; 59
  26:	f0 e0       	ldi	r31, 0x00	; 0
  28:	80 81       	ld	r24, Z
  2a:	66 e0       	ldi	r22, 0x06	; 6
  2c:	40 e0       	ldi	r20, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
	DIO_vidSetPortVal(PORTB_REG,Copy_Data);
  32:	e8 e3       	ldi	r30, 0x38	; 56
  34:	f0 e0       	ldi	r31, 0x00	; 0
  36:	80 81       	ld	r24, Z
  38:	6f 85       	ldd	r22, Y+15	; 0x0f
  3a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8HIGH);
  3e:	eb e3       	ldi	r30, 0x3B	; 59
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	80 81       	ld	r24, Z
  44:	67 e0       	ldi	r22, 0x07	; 7
  46:	41 e0       	ldi	r20, 0x01	; 1
  48:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	90 e0       	ldi	r25, 0x00	; 0
  50:	a0 e0       	ldi	r26, 0x00	; 0
  52:	b0 e4       	ldi	r27, 0x40	; 64
  54:	8b 87       	std	Y+11, r24	; 0x0b
  56:	9c 87       	std	Y+12, r25	; 0x0c
  58:	ad 87       	std	Y+13, r26	; 0x0d
  5a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  5c:	6b 85       	ldd	r22, Y+11	; 0x0b
  5e:	7c 85       	ldd	r23, Y+12	; 0x0c
  60:	8d 85       	ldd	r24, Y+13	; 0x0d
  62:	9e 85       	ldd	r25, Y+14	; 0x0e
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	30 e0       	ldi	r19, 0x00	; 0
  68:	4a ef       	ldi	r20, 0xFA	; 250
  6a:	54 e4       	ldi	r21, 0x44	; 68
  6c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
  70:	dc 01       	movw	r26, r24
  72:	cb 01       	movw	r24, r22
  74:	8f 83       	std	Y+7, r24	; 0x07
  76:	98 87       	std	Y+8, r25	; 0x08
  78:	a9 87       	std	Y+9, r26	; 0x09
  7a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
  7c:	6f 81       	ldd	r22, Y+7	; 0x07
  7e:	78 85       	ldd	r23, Y+8	; 0x08
  80:	89 85       	ldd	r24, Y+9	; 0x09
  82:	9a 85       	ldd	r25, Y+10	; 0x0a
  84:	20 e0       	ldi	r18, 0x00	; 0
  86:	30 e0       	ldi	r19, 0x00	; 0
  88:	40 e8       	ldi	r20, 0x80	; 128
  8a:	5f e3       	ldi	r21, 0x3F	; 63
  8c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
  90:	88 23       	and	r24, r24
  92:	04 f4       	brge	.+0      	; 0x94 <LCD_vidSendCommand+0x94>
		__ticks = 1;
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	9e 83       	std	Y+6, r25	; 0x06
  9a:	8d 83       	std	Y+5, r24	; 0x05
  9c:	00 c0       	rjmp	.+0      	; 0x9e <LCD_vidSendCommand+0x9e>
	else if (__tmp > 65535)
  9e:	6f 81       	ldd	r22, Y+7	; 0x07
  a0:	78 85       	ldd	r23, Y+8	; 0x08
  a2:	89 85       	ldd	r24, Y+9	; 0x09
  a4:	9a 85       	ldd	r25, Y+10	; 0x0a
  a6:	20 e0       	ldi	r18, 0x00	; 0
  a8:	3f ef       	ldi	r19, 0xFF	; 255
  aa:	4f e7       	ldi	r20, 0x7F	; 127
  ac:	57 e4       	ldi	r21, 0x47	; 71
  ae:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
  b2:	18 16       	cp	r1, r24
  b4:	04 f4       	brge	.+0      	; 0xb6 <LCD_vidSendCommand+0xb6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  b6:	6b 85       	ldd	r22, Y+11	; 0x0b
  b8:	7c 85       	ldd	r23, Y+12	; 0x0c
  ba:	8d 85       	ldd	r24, Y+13	; 0x0d
  bc:	9e 85       	ldd	r25, Y+14	; 0x0e
  be:	20 e0       	ldi	r18, 0x00	; 0
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	40 e2       	ldi	r20, 0x20	; 32
  c4:	51 e4       	ldi	r21, 0x41	; 65
  c6:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
  ca:	dc 01       	movw	r26, r24
  cc:	cb 01       	movw	r24, r22
  ce:	bc 01       	movw	r22, r24
  d0:	cd 01       	movw	r24, r26
  d2:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
  d6:	dc 01       	movw	r26, r24
  d8:	cb 01       	movw	r24, r22
  da:	9e 83       	std	Y+6, r25	; 0x06
  dc:	8d 83       	std	Y+5, r24	; 0x05
  de:	00 c0       	rjmp	.+0      	; 0xe0 <LCD_vidSendCommand+0xe0>
  e0:	88 ec       	ldi	r24, 0xC8	; 200
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	9c 83       	std	Y+4, r25	; 0x04
  e6:	8b 83       	std	Y+3, r24	; 0x03
  e8:	8b 81       	ldd	r24, Y+3	; 0x03
  ea:	9c 81       	ldd	r25, Y+4	; 0x04
  ec:	01 97       	sbiw	r24, 0x01	; 1
  ee:	01 f4       	brne	.+0      	; 0xf0 <LCD_vidSendCommand+0xf0>
  f0:	9c 83       	std	Y+4, r25	; 0x04
  f2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  f4:	8d 81       	ldd	r24, Y+5	; 0x05
  f6:	9e 81       	ldd	r25, Y+6	; 0x06
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	9e 83       	std	Y+6, r25	; 0x06
  fc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  fe:	8d 81       	ldd	r24, Y+5	; 0x05
 100:	9e 81       	ldd	r25, Y+6	; 0x06
 102:	00 97       	sbiw	r24, 0x00	; 0
 104:	01 f4       	brne	.+0      	; 0x106 <LCD_vidSendCommand+0x106>
 106:	00 c0       	rjmp	.+0      	; 0x108 <LCD_vidSendCommand+0x108>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 108:	6f 81       	ldd	r22, Y+7	; 0x07
 10a:	78 85       	ldd	r23, Y+8	; 0x08
 10c:	89 85       	ldd	r24, Y+9	; 0x09
 10e:	9a 85       	ldd	r25, Y+10	; 0x0a
 110:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
 114:	dc 01       	movw	r26, r24
 116:	cb 01       	movw	r24, r22
 118:	9e 83       	std	Y+6, r25	; 0x06
 11a:	8d 83       	std	Y+5, r24	; 0x05
 11c:	8d 81       	ldd	r24, Y+5	; 0x05
 11e:	9e 81       	ldd	r25, Y+6	; 0x06
 120:	9a 83       	std	Y+2, r25	; 0x02
 122:	89 83       	std	Y+1, r24	; 0x01
 124:	89 81       	ldd	r24, Y+1	; 0x01
 126:	9a 81       	ldd	r25, Y+2	; 0x02
 128:	01 97       	sbiw	r24, 0x01	; 1
 12a:	01 f4       	brne	.+0      	; 0x12c <LCD_vidSendCommand+0x12c>
 12c:	9a 83       	std	Y+2, r25	; 0x02
 12e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8LOW);
 130:	eb e3       	ldi	r30, 0x3B	; 59
 132:	f0 e0       	ldi	r31, 0x00	; 0
 134:	80 81       	ld	r24, Z
 136:	67 e0       	ldi	r22, 0x07	; 7
 138:	40 e0       	ldi	r20, 0x00	; 0
 13a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidSendCommand>
}
 13e:	2f 96       	adiw	r28, 0x0f	; 15
 140:	0f b6       	in	r0, 0x3f	; 63
 142:	f8 94       	cli
 144:	de bf       	out	0x3e, r29	; 62
 146:	0f be       	out	0x3f, r0	; 63
 148:	cd bf       	out	0x3d, r28	; 61
 14a:	cf 91       	pop	r28
 14c:	df 91       	pop	r29
 14e:	08 95       	ret

Disassembly of section .text.LCD_vidWriteString:

00000000 <LCD_vidWriteString>:
#include "DIO_int.h"
#include "LCD_int.h"
#include "ATMEGA32_REGISTERS.h"

void LCD_vidWriteData(u8 Copy_Data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LCD_vidWriteString+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LCD_vidWriteString+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9c 83       	std	Y+4, r25	; 0x04
   e:	8b 83       	std	Y+3, r24	; 0x03
  10:	1a 82       	std	Y+2, r1	; 0x02
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	00 c0       	rjmp	.+0      	; 0x16 <LCD_vidWriteString+0x16>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_5,DIO_u8HIGH);
  16:	29 81       	ldd	r18, Y+1	; 0x01
  18:	3a 81       	ldd	r19, Y+2	; 0x02
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	fc 01       	movw	r30, r24
  20:	e2 0f       	add	r30, r18
  22:	f3 1f       	adc	r31, r19
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_6,DIO_u8LOW);
  24:	80 81       	ld	r24, Z
  26:	0e 94 00 00 	call	0	; 0x0 <LCD_vidWriteString>
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	9a 81       	ldd	r25, Y+2	; 0x02
  2e:	01 96       	adiw	r24, 0x01	; 1
  30:	9a 83       	std	Y+2, r25	; 0x02
	DIO_vidSetPortVal(PORTB_REG,Copy_Data);
  32:	89 83       	std	Y+1, r24	; 0x01
  34:	29 81       	ldd	r18, Y+1	; 0x01
  36:	3a 81       	ldd	r19, Y+2	; 0x02
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	9c 81       	ldd	r25, Y+4	; 0x04
  3c:	fc 01       	movw	r30, r24
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8HIGH);
  3e:	e2 0f       	add	r30, r18
  40:	f3 1f       	adc	r31, r19
  42:	80 81       	ld	r24, Z
  44:	88 23       	and	r24, r24
  46:	01 f4       	brne	.+0      	; 0x48 <LCD_vidWriteString+0x48>
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	0f 90       	pop	r0
  4e:	0f 90       	pop	r0
  50:	cf 91       	pop	r28
  52:	df 91       	pop	r29
  54:	08 95       	ret

Disassembly of section .text.LCD_vidInit:

00000000 <LCD_vidInit>:
#include "DIO_int.h"
#include "LCD_int.h"
#include "ATMEGA32_REGISTERS.h"

void LCD_vidWriteData(u8 Copy_Data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e8 97       	sbiw	r28, 0x38	; 56
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	eb e3       	ldi	r30, 0x3B	; 59
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_5,DIO_u8HIGH);
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	65 e0       	ldi	r22, 0x05	; 5
  1c:	41 e0       	ldi	r20, 0x01	; 1
  1e:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
  22:	eb e3       	ldi	r30, 0x3B	; 59
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_6,DIO_u8LOW);
  24:	f0 e0       	ldi	r31, 0x00	; 0
  26:	80 81       	ld	r24, Z
  28:	66 e0       	ldi	r22, 0x06	; 6
  2a:	41 e0       	ldi	r20, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
  30:	eb e3       	ldi	r30, 0x3B	; 59
	DIO_vidSetPortVal(PORTB_REG,Copy_Data);
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
  36:	67 e0       	ldi	r22, 0x07	; 7
  38:	41 e0       	ldi	r20, 0x01	; 1
  3a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8HIGH);
  3e:	e8 e3       	ldi	r30, 0x38	; 56
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	80 81       	ld	r24, Z
  44:	88 2f       	mov	r24, r24
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	6f ef       	ldi	r22, 0xFF	; 255
  4a:	70 e0       	ldi	r23, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
  50:	80 e0       	ldi	r24, 0x00	; 0
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	a8 e4       	ldi	r26, 0x48	; 72
  56:	b2 e4       	ldi	r27, 0x42	; 66
  58:	8d ab       	std	Y+53, r24	; 0x35
  5a:	9e ab       	std	Y+54, r25	; 0x36
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  5c:	af ab       	std	Y+55, r26	; 0x37
  5e:	b8 af       	std	Y+56, r27	; 0x38
  60:	6d a9       	ldd	r22, Y+53	; 0x35
  62:	7e a9       	ldd	r23, Y+54	; 0x36
  64:	8f a9       	ldd	r24, Y+55	; 0x37
  66:	98 ad       	ldd	r25, Y+56	; 0x38
  68:	20 e0       	ldi	r18, 0x00	; 0
  6a:	30 e0       	ldi	r19, 0x00	; 0
  6c:	4a ef       	ldi	r20, 0xFA	; 250
  6e:	54 e4       	ldi	r21, 0x44	; 68
  70:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
  74:	dc 01       	movw	r26, r24
  76:	cb 01       	movw	r24, r22
  78:	89 ab       	std	Y+49, r24	; 0x31
  7a:	9a ab       	std	Y+50, r25	; 0x32
	if (__tmp < 1.0)
  7c:	ab ab       	std	Y+51, r26	; 0x33
  7e:	bc ab       	std	Y+52, r27	; 0x34
  80:	69 a9       	ldd	r22, Y+49	; 0x31
  82:	7a a9       	ldd	r23, Y+50	; 0x32
  84:	8b a9       	ldd	r24, Y+51	; 0x33
  86:	9c a9       	ldd	r25, Y+52	; 0x34
  88:	20 e0       	ldi	r18, 0x00	; 0
  8a:	30 e0       	ldi	r19, 0x00	; 0
  8c:	40 e8       	ldi	r20, 0x80	; 128
  8e:	5f e3       	ldi	r21, 0x3F	; 63
  90:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
		__ticks = 1;
  94:	88 23       	and	r24, r24
  96:	04 f4       	brge	.+0      	; 0x98 <LCD_vidInit+0x98>
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	98 ab       	std	Y+48, r25	; 0x30
	else if (__tmp > 65535)
  9e:	8f a7       	std	Y+47, r24	; 0x2f
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <LCD_vidInit+0xa2>
  a2:	69 a9       	ldd	r22, Y+49	; 0x31
  a4:	7a a9       	ldd	r23, Y+50	; 0x32
  a6:	8b a9       	ldd	r24, Y+51	; 0x33
  a8:	9c a9       	ldd	r25, Y+52	; 0x34
  aa:	20 e0       	ldi	r18, 0x00	; 0
  ac:	3f ef       	ldi	r19, 0xFF	; 255
  ae:	4f e7       	ldi	r20, 0x7F	; 127
  b0:	57 e4       	ldi	r21, 0x47	; 71
  b2:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  b6:	18 16       	cp	r1, r24
  b8:	04 f4       	brge	.+0      	; 0xba <LCD_vidInit+0xba>
  ba:	6d a9       	ldd	r22, Y+53	; 0x35
  bc:	7e a9       	ldd	r23, Y+54	; 0x36
  be:	8f a9       	ldd	r24, Y+55	; 0x37
  c0:	98 ad       	ldd	r25, Y+56	; 0x38
  c2:	20 e0       	ldi	r18, 0x00	; 0
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	40 e2       	ldi	r20, 0x20	; 32
  c8:	51 e4       	ldi	r21, 0x41	; 65
  ca:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
  ce:	dc 01       	movw	r26, r24
  d0:	cb 01       	movw	r24, r22
  d2:	bc 01       	movw	r22, r24
  d4:	cd 01       	movw	r24, r26
  d6:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
  da:	dc 01       	movw	r26, r24
  dc:	cb 01       	movw	r24, r22
  de:	98 ab       	std	Y+48, r25	; 0x30
  e0:	8f a7       	std	Y+47, r24	; 0x2f
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <LCD_vidInit+0xe4>
  e4:	88 ec       	ldi	r24, 0xC8	; 200
  e6:	90 e0       	ldi	r25, 0x00	; 0
  e8:	9e a7       	std	Y+46, r25	; 0x2e
  ea:	8d a7       	std	Y+45, r24	; 0x2d
  ec:	8d a5       	ldd	r24, Y+45	; 0x2d
  ee:	9e a5       	ldd	r25, Y+46	; 0x2e
  f0:	01 97       	sbiw	r24, 0x01	; 1
  f2:	01 f4       	brne	.+0      	; 0xf4 <LCD_vidInit+0xf4>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  f4:	9e a7       	std	Y+46, r25	; 0x2e
  f6:	8d a7       	std	Y+45, r24	; 0x2d
  f8:	8f a5       	ldd	r24, Y+47	; 0x2f
  fa:	98 a9       	ldd	r25, Y+48	; 0x30
  fc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  fe:	98 ab       	std	Y+48, r25	; 0x30
 100:	8f a7       	std	Y+47, r24	; 0x2f
 102:	8f a5       	ldd	r24, Y+47	; 0x2f
 104:	98 a9       	ldd	r25, Y+48	; 0x30
 106:	00 97       	sbiw	r24, 0x00	; 0
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 108:	01 f4       	brne	.+0      	; 0x10a <LCD_vidInit+0x10a>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <LCD_vidInit+0x10c>
 10c:	69 a9       	ldd	r22, Y+49	; 0x31
 10e:	7a a9       	ldd	r23, Y+50	; 0x32
 110:	8b a9       	ldd	r24, Y+51	; 0x33
 112:	9c a9       	ldd	r25, Y+52	; 0x34
 114:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 118:	dc 01       	movw	r26, r24
 11a:	cb 01       	movw	r24, r22
 11c:	98 ab       	std	Y+48, r25	; 0x30
 11e:	8f a7       	std	Y+47, r24	; 0x2f
 120:	8f a5       	ldd	r24, Y+47	; 0x2f
 122:	98 a9       	ldd	r25, Y+48	; 0x30
 124:	9c a7       	std	Y+44, r25	; 0x2c
 126:	8b a7       	std	Y+43, r24	; 0x2b
 128:	8b a5       	ldd	r24, Y+43	; 0x2b
 12a:	9c a5       	ldd	r25, Y+44	; 0x2c
 12c:	01 97       	sbiw	r24, 0x01	; 1
 12e:	01 f4       	brne	.+0      	; 0x130 <LCD_vidInit+0x130>
	_delay_ms(2);
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8LOW);
 130:	9c a7       	std	Y+44, r25	; 0x2c
 132:	8b a7       	std	Y+43, r24	; 0x2b
 134:	88 e3       	ldi	r24, 0x38	; 56
 136:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	90 e0       	ldi	r25, 0x00	; 0
}
 13e:	a0 e8       	ldi	r26, 0x80	; 128
 140:	bf e3       	ldi	r27, 0x3F	; 63
 142:	8f a3       	std	Y+39, r24	; 0x27
 144:	98 a7       	std	Y+40, r25	; 0x28
 146:	a9 a7       	std	Y+41, r26	; 0x29
 148:	ba a7       	std	Y+42, r27	; 0x2a
 14a:	6f a1       	ldd	r22, Y+39	; 0x27
 14c:	78 a5       	ldd	r23, Y+40	; 0x28
 14e:	89 a5       	ldd	r24, Y+41	; 0x29
 150:	9a a5       	ldd	r25, Y+42	; 0x2a
 152:	20 e0       	ldi	r18, 0x00	; 0
 154:	30 e0       	ldi	r19, 0x00	; 0
 156:	4a ef       	ldi	r20, 0xFA	; 250
 158:	54 e4       	ldi	r21, 0x44	; 68
 15a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 15e:	dc 01       	movw	r26, r24
 160:	cb 01       	movw	r24, r22
 162:	8b a3       	std	Y+35, r24	; 0x23
 164:	9c a3       	std	Y+36, r25	; 0x24
 166:	ad a3       	std	Y+37, r26	; 0x25
 168:	be a3       	std	Y+38, r27	; 0x26
 16a:	6b a1       	ldd	r22, Y+35	; 0x23
 16c:	7c a1       	ldd	r23, Y+36	; 0x24
 16e:	8d a1       	ldd	r24, Y+37	; 0x25
 170:	9e a1       	ldd	r25, Y+38	; 0x26
 172:	20 e0       	ldi	r18, 0x00	; 0
 174:	30 e0       	ldi	r19, 0x00	; 0
 176:	40 e8       	ldi	r20, 0x80	; 128
 178:	5f e3       	ldi	r21, 0x3F	; 63
 17a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 17e:	88 23       	and	r24, r24
 180:	04 f4       	brge	.+0      	; 0x182 <LCD_vidInit+0x182>
 182:	81 e0       	ldi	r24, 0x01	; 1
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	9a a3       	std	Y+34, r25	; 0x22
 188:	89 a3       	std	Y+33, r24	; 0x21
 18a:	00 c0       	rjmp	.+0      	; 0x18c <LCD_vidInit+0x18c>
 18c:	6b a1       	ldd	r22, Y+35	; 0x23
 18e:	7c a1       	ldd	r23, Y+36	; 0x24
 190:	8d a1       	ldd	r24, Y+37	; 0x25
 192:	9e a1       	ldd	r25, Y+38	; 0x26
 194:	20 e0       	ldi	r18, 0x00	; 0
 196:	3f ef       	ldi	r19, 0xFF	; 255
 198:	4f e7       	ldi	r20, 0x7F	; 127
 19a:	57 e4       	ldi	r21, 0x47	; 71
 19c:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 1a0:	18 16       	cp	r1, r24
 1a2:	04 f4       	brge	.+0      	; 0x1a4 <LCD_vidInit+0x1a4>
 1a4:	6f a1       	ldd	r22, Y+39	; 0x27
 1a6:	78 a5       	ldd	r23, Y+40	; 0x28
 1a8:	89 a5       	ldd	r24, Y+41	; 0x29
 1aa:	9a a5       	ldd	r25, Y+42	; 0x2a
 1ac:	20 e0       	ldi	r18, 0x00	; 0
 1ae:	30 e0       	ldi	r19, 0x00	; 0
 1b0:	40 e2       	ldi	r20, 0x20	; 32
 1b2:	51 e4       	ldi	r21, 0x41	; 65
 1b4:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 1b8:	dc 01       	movw	r26, r24
 1ba:	cb 01       	movw	r24, r22
 1bc:	bc 01       	movw	r22, r24
 1be:	cd 01       	movw	r24, r26
 1c0:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 1c4:	dc 01       	movw	r26, r24
 1c6:	cb 01       	movw	r24, r22
 1c8:	9a a3       	std	Y+34, r25	; 0x22
 1ca:	89 a3       	std	Y+33, r24	; 0x21
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <LCD_vidInit+0x1ce>
 1ce:	88 ec       	ldi	r24, 0xC8	; 200
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	98 a3       	std	Y+32, r25	; 0x20
 1d4:	8f 8f       	std	Y+31, r24	; 0x1f
 1d6:	8f 8d       	ldd	r24, Y+31	; 0x1f
 1d8:	98 a1       	ldd	r25, Y+32	; 0x20
 1da:	01 97       	sbiw	r24, 0x01	; 1
 1dc:	01 f4       	brne	.+0      	; 0x1de <LCD_vidInit+0x1de>
 1de:	98 a3       	std	Y+32, r25	; 0x20
 1e0:	8f 8f       	std	Y+31, r24	; 0x1f
 1e2:	89 a1       	ldd	r24, Y+33	; 0x21
 1e4:	9a a1       	ldd	r25, Y+34	; 0x22
 1e6:	01 97       	sbiw	r24, 0x01	; 1
 1e8:	9a a3       	std	Y+34, r25	; 0x22
 1ea:	89 a3       	std	Y+33, r24	; 0x21
 1ec:	89 a1       	ldd	r24, Y+33	; 0x21
 1ee:	9a a1       	ldd	r25, Y+34	; 0x22
 1f0:	00 97       	sbiw	r24, 0x00	; 0
 1f2:	01 f4       	brne	.+0      	; 0x1f4 <LCD_vidInit+0x1f4>
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <LCD_vidInit+0x1f6>
 1f6:	6b a1       	ldd	r22, Y+35	; 0x23
 1f8:	7c a1       	ldd	r23, Y+36	; 0x24
 1fa:	8d a1       	ldd	r24, Y+37	; 0x25
 1fc:	9e a1       	ldd	r25, Y+38	; 0x26
 1fe:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 202:	dc 01       	movw	r26, r24
 204:	cb 01       	movw	r24, r22
 206:	9a a3       	std	Y+34, r25	; 0x22
 208:	89 a3       	std	Y+33, r24	; 0x21
 20a:	89 a1       	ldd	r24, Y+33	; 0x21
 20c:	9a a1       	ldd	r25, Y+34	; 0x22
 20e:	9e 8f       	std	Y+30, r25	; 0x1e
 210:	8d 8f       	std	Y+29, r24	; 0x1d
 212:	8d 8d       	ldd	r24, Y+29	; 0x1d
 214:	9e 8d       	ldd	r25, Y+30	; 0x1e
 216:	01 97       	sbiw	r24, 0x01	; 1
 218:	01 f4       	brne	.+0      	; 0x21a <LCD_vidInit+0x21a>
 21a:	9e 8f       	std	Y+30, r25	; 0x1e
 21c:	8d 8f       	std	Y+29, r24	; 0x1d
 21e:	8f e0       	ldi	r24, 0x0F	; 15
 220:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 224:	80 e0       	ldi	r24, 0x00	; 0
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	a0 e8       	ldi	r26, 0x80	; 128
 22a:	bf e3       	ldi	r27, 0x3F	; 63
 22c:	89 8f       	std	Y+25, r24	; 0x19
 22e:	9a 8f       	std	Y+26, r25	; 0x1a
 230:	ab 8f       	std	Y+27, r26	; 0x1b
 232:	bc 8f       	std	Y+28, r27	; 0x1c
 234:	69 8d       	ldd	r22, Y+25	; 0x19
 236:	7a 8d       	ldd	r23, Y+26	; 0x1a
 238:	8b 8d       	ldd	r24, Y+27	; 0x1b
 23a:	9c 8d       	ldd	r25, Y+28	; 0x1c
 23c:	20 e0       	ldi	r18, 0x00	; 0
 23e:	30 e0       	ldi	r19, 0x00	; 0
 240:	4a ef       	ldi	r20, 0xFA	; 250
 242:	54 e4       	ldi	r21, 0x44	; 68
 244:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 248:	dc 01       	movw	r26, r24
 24a:	cb 01       	movw	r24, r22
 24c:	8d 8b       	std	Y+21, r24	; 0x15
 24e:	9e 8b       	std	Y+22, r25	; 0x16
 250:	af 8b       	std	Y+23, r26	; 0x17
 252:	b8 8f       	std	Y+24, r27	; 0x18
 254:	6d 89       	ldd	r22, Y+21	; 0x15
 256:	7e 89       	ldd	r23, Y+22	; 0x16
 258:	8f 89       	ldd	r24, Y+23	; 0x17
 25a:	98 8d       	ldd	r25, Y+24	; 0x18
 25c:	20 e0       	ldi	r18, 0x00	; 0
 25e:	30 e0       	ldi	r19, 0x00	; 0
 260:	40 e8       	ldi	r20, 0x80	; 128
 262:	5f e3       	ldi	r21, 0x3F	; 63
 264:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 268:	88 23       	and	r24, r24
 26a:	04 f4       	brge	.+0      	; 0x26c <LCD_vidInit+0x26c>
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	9c 8b       	std	Y+20, r25	; 0x14
 272:	8b 8b       	std	Y+19, r24	; 0x13
 274:	00 c0       	rjmp	.+0      	; 0x276 <LCD_vidInit+0x276>
 276:	6d 89       	ldd	r22, Y+21	; 0x15
 278:	7e 89       	ldd	r23, Y+22	; 0x16
 27a:	8f 89       	ldd	r24, Y+23	; 0x17
 27c:	98 8d       	ldd	r25, Y+24	; 0x18
 27e:	20 e0       	ldi	r18, 0x00	; 0
 280:	3f ef       	ldi	r19, 0xFF	; 255
 282:	4f e7       	ldi	r20, 0x7F	; 127
 284:	57 e4       	ldi	r21, 0x47	; 71
 286:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 28a:	18 16       	cp	r1, r24
 28c:	04 f4       	brge	.+0      	; 0x28e <LCD_vidInit+0x28e>
 28e:	69 8d       	ldd	r22, Y+25	; 0x19
 290:	7a 8d       	ldd	r23, Y+26	; 0x1a
 292:	8b 8d       	ldd	r24, Y+27	; 0x1b
 294:	9c 8d       	ldd	r25, Y+28	; 0x1c
 296:	20 e0       	ldi	r18, 0x00	; 0
 298:	30 e0       	ldi	r19, 0x00	; 0
 29a:	40 e2       	ldi	r20, 0x20	; 32
 29c:	51 e4       	ldi	r21, 0x41	; 65
 29e:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 2a2:	dc 01       	movw	r26, r24
 2a4:	cb 01       	movw	r24, r22
 2a6:	bc 01       	movw	r22, r24
 2a8:	cd 01       	movw	r24, r26
 2aa:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 2ae:	dc 01       	movw	r26, r24
 2b0:	cb 01       	movw	r24, r22
 2b2:	9c 8b       	std	Y+20, r25	; 0x14
 2b4:	8b 8b       	std	Y+19, r24	; 0x13
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <LCD_vidInit+0x2b8>
 2b8:	88 ec       	ldi	r24, 0xC8	; 200
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	9a 8b       	std	Y+18, r25	; 0x12
 2be:	89 8b       	std	Y+17, r24	; 0x11
 2c0:	89 89       	ldd	r24, Y+17	; 0x11
 2c2:	9a 89       	ldd	r25, Y+18	; 0x12
 2c4:	01 97       	sbiw	r24, 0x01	; 1
 2c6:	01 f4       	brne	.+0      	; 0x2c8 <LCD_vidInit+0x2c8>
 2c8:	9a 8b       	std	Y+18, r25	; 0x12
 2ca:	89 8b       	std	Y+17, r24	; 0x11
 2cc:	8b 89       	ldd	r24, Y+19	; 0x13
 2ce:	9c 89       	ldd	r25, Y+20	; 0x14
 2d0:	01 97       	sbiw	r24, 0x01	; 1
 2d2:	9c 8b       	std	Y+20, r25	; 0x14
 2d4:	8b 8b       	std	Y+19, r24	; 0x13
 2d6:	8b 89       	ldd	r24, Y+19	; 0x13
 2d8:	9c 89       	ldd	r25, Y+20	; 0x14
 2da:	00 97       	sbiw	r24, 0x00	; 0
 2dc:	01 f4       	brne	.+0      	; 0x2de <LCD_vidInit+0x2de>
 2de:	00 c0       	rjmp	.+0      	; 0x2e0 <LCD_vidInit+0x2e0>
 2e0:	6d 89       	ldd	r22, Y+21	; 0x15
 2e2:	7e 89       	ldd	r23, Y+22	; 0x16
 2e4:	8f 89       	ldd	r24, Y+23	; 0x17
 2e6:	98 8d       	ldd	r25, Y+24	; 0x18
 2e8:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 2ec:	dc 01       	movw	r26, r24
 2ee:	cb 01       	movw	r24, r22
 2f0:	9c 8b       	std	Y+20, r25	; 0x14
 2f2:	8b 8b       	std	Y+19, r24	; 0x13
 2f4:	8b 89       	ldd	r24, Y+19	; 0x13
 2f6:	9c 89       	ldd	r25, Y+20	; 0x14
 2f8:	98 8b       	std	Y+16, r25	; 0x10
 2fa:	8f 87       	std	Y+15, r24	; 0x0f
 2fc:	8f 85       	ldd	r24, Y+15	; 0x0f
 2fe:	98 89       	ldd	r25, Y+16	; 0x10
 300:	01 97       	sbiw	r24, 0x01	; 1
 302:	01 f4       	brne	.+0      	; 0x304 <LCD_vidInit+0x304>
 304:	98 8b       	std	Y+16, r25	; 0x10
 306:	8f 87       	std	Y+15, r24	; 0x0f
 308:	81 e0       	ldi	r24, 0x01	; 1
 30a:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 30e:	80 e0       	ldi	r24, 0x00	; 0
 310:	90 e0       	ldi	r25, 0x00	; 0
 312:	a0 e0       	ldi	r26, 0x00	; 0
 314:	b0 e4       	ldi	r27, 0x40	; 64
 316:	8b 87       	std	Y+11, r24	; 0x0b
 318:	9c 87       	std	Y+12, r25	; 0x0c
 31a:	ad 87       	std	Y+13, r26	; 0x0d
 31c:	be 87       	std	Y+14, r27	; 0x0e
 31e:	6b 85       	ldd	r22, Y+11	; 0x0b
 320:	7c 85       	ldd	r23, Y+12	; 0x0c
 322:	8d 85       	ldd	r24, Y+13	; 0x0d
 324:	9e 85       	ldd	r25, Y+14	; 0x0e
 326:	20 e0       	ldi	r18, 0x00	; 0
 328:	30 e0       	ldi	r19, 0x00	; 0
 32a:	4a ef       	ldi	r20, 0xFA	; 250
 32c:	54 e4       	ldi	r21, 0x44	; 68
 32e:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 332:	dc 01       	movw	r26, r24
 334:	cb 01       	movw	r24, r22
 336:	8f 83       	std	Y+7, r24	; 0x07
 338:	98 87       	std	Y+8, r25	; 0x08
 33a:	a9 87       	std	Y+9, r26	; 0x09
 33c:	ba 87       	std	Y+10, r27	; 0x0a
 33e:	6f 81       	ldd	r22, Y+7	; 0x07
 340:	78 85       	ldd	r23, Y+8	; 0x08
 342:	89 85       	ldd	r24, Y+9	; 0x09
 344:	9a 85       	ldd	r25, Y+10	; 0x0a
 346:	20 e0       	ldi	r18, 0x00	; 0
 348:	30 e0       	ldi	r19, 0x00	; 0
 34a:	40 e8       	ldi	r20, 0x80	; 128
 34c:	5f e3       	ldi	r21, 0x3F	; 63
 34e:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 352:	88 23       	and	r24, r24
 354:	04 f4       	brge	.+0      	; 0x356 <LCD_vidInit+0x356>
 356:	81 e0       	ldi	r24, 0x01	; 1
 358:	90 e0       	ldi	r25, 0x00	; 0
 35a:	9e 83       	std	Y+6, r25	; 0x06
 35c:	8d 83       	std	Y+5, r24	; 0x05
 35e:	00 c0       	rjmp	.+0      	; 0x360 <LCD_vidInit+0x360>
 360:	6f 81       	ldd	r22, Y+7	; 0x07
 362:	78 85       	ldd	r23, Y+8	; 0x08
 364:	89 85       	ldd	r24, Y+9	; 0x09
 366:	9a 85       	ldd	r25, Y+10	; 0x0a
 368:	20 e0       	ldi	r18, 0x00	; 0
 36a:	3f ef       	ldi	r19, 0xFF	; 255
 36c:	4f e7       	ldi	r20, 0x7F	; 127
 36e:	57 e4       	ldi	r21, 0x47	; 71
 370:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 374:	18 16       	cp	r1, r24
 376:	04 f4       	brge	.+0      	; 0x378 <LCD_vidInit+0x378>
 378:	6b 85       	ldd	r22, Y+11	; 0x0b
 37a:	7c 85       	ldd	r23, Y+12	; 0x0c
 37c:	8d 85       	ldd	r24, Y+13	; 0x0d
 37e:	9e 85       	ldd	r25, Y+14	; 0x0e
 380:	20 e0       	ldi	r18, 0x00	; 0
 382:	30 e0       	ldi	r19, 0x00	; 0
 384:	40 e2       	ldi	r20, 0x20	; 32
 386:	51 e4       	ldi	r21, 0x41	; 65
 388:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 38c:	dc 01       	movw	r26, r24
 38e:	cb 01       	movw	r24, r22
 390:	bc 01       	movw	r22, r24
 392:	cd 01       	movw	r24, r26
 394:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 398:	dc 01       	movw	r26, r24
 39a:	cb 01       	movw	r24, r22
 39c:	9e 83       	std	Y+6, r25	; 0x06
 39e:	8d 83       	std	Y+5, r24	; 0x05
 3a0:	00 c0       	rjmp	.+0      	; 0x3a2 <LCD_vidInit+0x3a2>
 3a2:	88 ec       	ldi	r24, 0xC8	; 200
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	9c 83       	std	Y+4, r25	; 0x04
 3a8:	8b 83       	std	Y+3, r24	; 0x03
 3aa:	8b 81       	ldd	r24, Y+3	; 0x03
 3ac:	9c 81       	ldd	r25, Y+4	; 0x04
 3ae:	01 97       	sbiw	r24, 0x01	; 1
 3b0:	01 f4       	brne	.+0      	; 0x3b2 <LCD_vidInit+0x3b2>
 3b2:	9c 83       	std	Y+4, r25	; 0x04
 3b4:	8b 83       	std	Y+3, r24	; 0x03
 3b6:	8d 81       	ldd	r24, Y+5	; 0x05
 3b8:	9e 81       	ldd	r25, Y+6	; 0x06
 3ba:	01 97       	sbiw	r24, 0x01	; 1
 3bc:	9e 83       	std	Y+6, r25	; 0x06
 3be:	8d 83       	std	Y+5, r24	; 0x05
 3c0:	8d 81       	ldd	r24, Y+5	; 0x05
 3c2:	9e 81       	ldd	r25, Y+6	; 0x06
 3c4:	00 97       	sbiw	r24, 0x00	; 0
 3c6:	01 f4       	brne	.+0      	; 0x3c8 <LCD_vidInit+0x3c8>
 3c8:	00 c0       	rjmp	.+0      	; 0x3ca <LCD_vidInit+0x3ca>
 3ca:	6f 81       	ldd	r22, Y+7	; 0x07
 3cc:	78 85       	ldd	r23, Y+8	; 0x08
 3ce:	89 85       	ldd	r24, Y+9	; 0x09
 3d0:	9a 85       	ldd	r25, Y+10	; 0x0a
 3d2:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 3d6:	dc 01       	movw	r26, r24
 3d8:	cb 01       	movw	r24, r22
 3da:	9e 83       	std	Y+6, r25	; 0x06
 3dc:	8d 83       	std	Y+5, r24	; 0x05
 3de:	8d 81       	ldd	r24, Y+5	; 0x05
 3e0:	9e 81       	ldd	r25, Y+6	; 0x06
 3e2:	9a 83       	std	Y+2, r25	; 0x02
 3e4:	89 83       	std	Y+1, r24	; 0x01
 3e6:	89 81       	ldd	r24, Y+1	; 0x01
 3e8:	9a 81       	ldd	r25, Y+2	; 0x02
 3ea:	01 97       	sbiw	r24, 0x01	; 1
 3ec:	01 f4       	brne	.+0      	; 0x3ee <LCD_vidInit+0x3ee>
 3ee:	9a 83       	std	Y+2, r25	; 0x02
 3f0:	89 83       	std	Y+1, r24	; 0x01
 3f2:	86 e0       	ldi	r24, 0x06	; 6
 3f4:	0e 94 00 00 	call	0	; 0x0 <LCD_vidInit>
 3f8:	e8 96       	adiw	r28, 0x38	; 56
 3fa:	0f b6       	in	r0, 0x3f	; 63
 3fc:	f8 94       	cli
 3fe:	de bf       	out	0x3e, r29	; 62
 400:	0f be       	out	0x3f, r0	; 63
 402:	cd bf       	out	0x3d, r28	; 61
 404:	cf 91       	pop	r28
 406:	df 91       	pop	r29
 408:	08 95       	ret

Disassembly of section .text.LCD_vidGoTo:

00000000 <LCD_vidGoTo>:
#include "DIO_int.h"
#include "LCD_int.h"
#include "ATMEGA32_REGISTERS.h"

void LCD_vidWriteData(u8 Copy_Data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LCD_vidGoTo+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LCD_vidGoTo+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	80 31       	cpi	r24, 0x10	; 16
  14:	00 f4       	brcc	.+0      	; 0x16 <LCD_vidGoTo+0x16>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_5,DIO_u8HIGH);
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3c 83       	std	Y+4, r19	; 0x04
  1e:	2b 83       	std	Y+3, r18	; 0x03
  20:	8b 81       	ldd	r24, Y+3	; 0x03
  22:	9c 81       	ldd	r25, Y+4	; 0x04
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_6,DIO_u8LOW);
  24:	00 97       	sbiw	r24, 0x00	; 0
  26:	01 f0       	breq	.+0      	; 0x28 <LCD_vidGoTo+0x28>
  28:	2b 81       	ldd	r18, Y+3	; 0x03
  2a:	3c 81       	ldd	r19, Y+4	; 0x04
  2c:	21 30       	cpi	r18, 0x01	; 1
  2e:	31 05       	cpc	r19, r1
  30:	01 f0       	breq	.+0      	; 0x32 <LCD_vidGoTo+0x32>
	DIO_vidSetPortVal(PORTB_REG,Copy_Data);
  32:	00 c0       	rjmp	.+0      	; 0x34 <LCD_vidGoTo+0x34>
  34:	8a 81       	ldd	r24, Y+2	; 0x02
  36:	80 58       	subi	r24, 0x80	; 128
  38:	0e 94 00 00 	call	0	; 0x0 <LCD_vidGoTo>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <LCD_vidGoTo+0x3e>
	DIO_vidSetPinVal(PORTA_REG,DIO_u8PIN_7,DIO_u8HIGH);
  3e:	8a 81       	ldd	r24, Y+2	; 0x02
  40:	80 54       	subi	r24, 0x40	; 64
  42:	0e 94 00 00 	call	0	; 0x0 <LCD_vidGoTo>
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	0f 90       	pop	r0
  4e:	cf 91       	pop	r28
  50:	df 91       	pop	r29
  52:	08 95       	ret

PWM_prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000360  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000047e  00000000  00000000  00000394  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.PWM_vidPwmInit 000000aa  00000000  00000000  00000812  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.PWM_vidSetPwmDutyCycle 000000f2  00000000  00000000  000008bc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.PWM_StartTimer 00000072  00000000  00000000  000009ae  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.PWM_StopTimer 00000056  00000000  00000000  00000a20  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.PWM_vidPwmInit:

00000000 <PWM_vidPwmInit>:
#include "PWM_int.h"
#include "GPT_int.h"
#include "DIO_int.h"

void PWM_vidPwmInit(u8 Copy_TimerNo)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <PWM_vidPwmInit+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_TimerNo)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	00 97       	sbiw	r24, 0x00	; 0
  1e:	01 f0       	breq	.+0      	; 0x20 <PWM_vidPwmInit+0x20>
  20:	2a 81       	ldd	r18, Y+2	; 0x02
  22:	3b 81       	ldd	r19, Y+3	; 0x03
  24:	21 30       	cpi	r18, 0x01	; 1
  26:	31 05       	cpc	r19, r1
  28:	01 f0       	breq	.+0      	; 0x2a <PWM_vidPwmInit+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <PWM_vidPwmInit+0x2c>
	{
	case TIMER_0: //if timer 0
		/*initializing timer 0  the same way we used it in GPT*/
		TCCR0_REG.Bits.BIT_3=1;
  2c:	e3 e5       	ldi	r30, 0x53	; 83
  2e:	f0 e0       	ldi	r31, 0x00	; 0
  30:	80 81       	ld	r24, Z
  32:	88 60       	ori	r24, 0x08	; 8
  34:	80 83       	st	Z, r24
		TCCR0_REG.Bits.BIT_6=1;
  36:	e3 e5       	ldi	r30, 0x53	; 83
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	80 81       	ld	r24, Z
  3c:	80 64       	ori	r24, 0x40	; 64
  3e:	80 83       	st	Z, r24
  40:	00 c0       	rjmp	.+0      	; 0x42 <PWM_vidPwmInit+0x42>
		break;
	case TIMER_1: //if timer 1
		/*initializing timer 1 changing some bits to match timer 1 */
		TCCR1A_REG.Bits.BIT_7 = 1;
  42:	ef e4       	ldi	r30, 0x4F	; 79
  44:	f0 e0       	ldi	r31, 0x00	; 0
  46:	80 81       	ld	r24, Z
  48:	80 68       	ori	r24, 0x80	; 128
  4a:	80 83       	st	Z, r24
		TCCR1A_REG.Bits.BIT_6 = 0;
  4c:	ef e4       	ldi	r30, 0x4F	; 79
  4e:	f0 e0       	ldi	r31, 0x00	; 0
  50:	80 81       	ld	r24, Z
  52:	8f 7b       	andi	r24, 0xBF	; 191
  54:	80 83       	st	Z, r24
		TCCR1A_REG.Bits.BIT_5 = 0;
  56:	ef e4       	ldi	r30, 0x4F	; 79
  58:	f0 e0       	ldi	r31, 0x00	; 0
  5a:	80 81       	ld	r24, Z
  5c:	8f 7d       	andi	r24, 0xDF	; 223
  5e:	80 83       	st	Z, r24
		TCCR1A_REG.Bits.BIT_4 = 0;
  60:	ef e4       	ldi	r30, 0x4F	; 79
  62:	f0 e0       	ldi	r31, 0x00	; 0
  64:	80 81       	ld	r24, Z
  66:	8f 7e       	andi	r24, 0xEF	; 239
  68:	80 83       	st	Z, r24
		/****************************/
		/* selecting fast pwm with ICR1 top*/
		TCCR1A_REG.Bits.BIT_0 = 0;
  6a:	ef e4       	ldi	r30, 0x4F	; 79
  6c:	f0 e0       	ldi	r31, 0x00	; 0
  6e:	80 81       	ld	r24, Z
  70:	8e 7f       	andi	r24, 0xFE	; 254
  72:	80 83       	st	Z, r24
		TCCR1A_REG.Bits.BIT_1 = 1;
  74:	ef e4       	ldi	r30, 0x4F	; 79
  76:	f0 e0       	ldi	r31, 0x00	; 0
  78:	80 81       	ld	r24, Z
  7a:	82 60       	ori	r24, 0x02	; 2
  7c:	80 83       	st	Z, r24

		TCCR1B_REG.Bits.BIT_3 = 1;
  7e:	ee e4       	ldi	r30, 0x4E	; 78
  80:	f0 e0       	ldi	r31, 0x00	; 0
  82:	80 81       	ld	r24, Z
  84:	88 60       	ori	r24, 0x08	; 8
  86:	80 83       	st	Z, r24
		TCCR1B_REG.Bits.BIT_4 = 1;
  88:	ee e4       	ldi	r30, 0x4E	; 78
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	80 81       	ld	r24, Z
  8e:	80 61       	ori	r24, 0x10	; 16
  90:	80 83       	st	Z, r24

		ICR1_REG = PWM_ICR1_VALUE; //initializing ICR1_VALUE to ICR1 register
  92:	e6 e4       	ldi	r30, 0x46	; 70
  94:	f0 e0       	ldi	r31, 0x00	; 0
  96:	84 ec       	ldi	r24, 0xC4	; 196
  98:	99 e0       	ldi	r25, 0x09	; 9
  9a:	91 83       	std	Z+1, r25	; 0x01
  9c:	80 83       	st	Z, r24
		break;
	}
}
  9e:	0f 90       	pop	r0
  a0:	0f 90       	pop	r0
  a2:	0f 90       	pop	r0
  a4:	cf 91       	pop	r28
  a6:	df 91       	pop	r29
  a8:	08 95       	ret

Disassembly of section .text.PWM_vidSetPwmDutyCycle:

00000000 <PWM_vidSetPwmDutyCycle>:
#include "PWM_int.h"
#include "GPT_int.h"
#include "DIO_int.h"

void PWM_vidPwmInit(u8 Copy_TimerNo)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	27 97       	sbiw	r28, 0x07	; 7
	switch(Copy_TimerNo)
   e:	0f b6       	in	r0, 0x3f	; 63
  10:	f8 94       	cli
  12:	de bf       	out	0x3e, r29	; 62
  14:	0f be       	out	0x3f, r0	; 63
  16:	cd bf       	out	0x3d, r28	; 61
  18:	89 83       	std	Y+1, r24	; 0x01
  1a:	4a 83       	std	Y+2, r20	; 0x02
  1c:	5b 83       	std	Y+3, r21	; 0x03
  1e:	6c 83       	std	Y+4, r22	; 0x04
  20:	7d 83       	std	Y+5, r23	; 0x05
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	28 2f       	mov	r18, r24
  26:	30 e0       	ldi	r19, 0x00	; 0
  28:	3f 83       	std	Y+7, r19	; 0x07
  2a:	2e 83       	std	Y+6, r18	; 0x06
	{
	case TIMER_0: //if timer 0
		/*initializing timer 0  the same way we used it in GPT*/
		TCCR0_REG.Bits.BIT_3=1;
  2c:	8e 81       	ldd	r24, Y+6	; 0x06
  2e:	9f 81       	ldd	r25, Y+7	; 0x07
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f0       	breq	.+0      	; 0x34 <PWM_vidSetPwmDutyCycle+0x34>
  34:	ee 81       	ldd	r30, Y+6	; 0x06
		TCCR0_REG.Bits.BIT_6=1;
  36:	ff 81       	ldd	r31, Y+7	; 0x07
  38:	e1 30       	cpi	r30, 0x01	; 1
  3a:	f1 05       	cpc	r31, r1
  3c:	01 f0       	breq	.+0      	; 0x3e <PWM_vidSetPwmDutyCycle+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <PWM_vidSetPwmDutyCycle+0x40>
  40:	0c e5       	ldi	r16, 0x5C	; 92
		break;
	case TIMER_1: //if timer 1
		/*initializing timer 1 changing some bits to match timer 1 */
		TCCR1A_REG.Bits.BIT_7 = 1;
  42:	10 e0       	ldi	r17, 0x00	; 0
  44:	6a 81       	ldd	r22, Y+2	; 0x02
  46:	7b 81       	ldd	r23, Y+3	; 0x03
  48:	8c 81       	ldd	r24, Y+4	; 0x04
  4a:	9d 81       	ldd	r25, Y+5	; 0x05
		TCCR1A_REG.Bits.BIT_6 = 0;
  4c:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  50:	dc 01       	movw	r26, r24
  52:	cb 01       	movw	r24, r22
  54:	bc 01       	movw	r22, r24
		TCCR1A_REG.Bits.BIT_5 = 0;
  56:	cd 01       	movw	r24, r26
  58:	20 e0       	ldi	r18, 0x00	; 0
  5a:	30 e0       	ldi	r19, 0x00	; 0
  5c:	40 e8       	ldi	r20, 0x80	; 128
  5e:	53 e4       	ldi	r21, 0x43	; 67
		TCCR1A_REG.Bits.BIT_4 = 0;
  60:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  64:	dc 01       	movw	r26, r24
  66:	cb 01       	movw	r24, r22
  68:	bc 01       	movw	r22, r24
		/****************************/
		/* selecting fast pwm with ICR1 top*/
		TCCR1A_REG.Bits.BIT_0 = 0;
  6a:	cd 01       	movw	r24, r26
  6c:	20 e0       	ldi	r18, 0x00	; 0
  6e:	30 e0       	ldi	r19, 0x00	; 0
  70:	48 ec       	ldi	r20, 0xC8	; 200
  72:	52 e4       	ldi	r21, 0x42	; 66
		TCCR1A_REG.Bits.BIT_1 = 1;
  74:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  78:	dc 01       	movw	r26, r24
  7a:	cb 01       	movw	r24, r22
  7c:	bc 01       	movw	r22, r24

		TCCR1B_REG.Bits.BIT_3 = 1;
  7e:	cd 01       	movw	r24, r26
  80:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  84:	dc 01       	movw	r26, r24
  86:	cb 01       	movw	r24, r22
		TCCR1B_REG.Bits.BIT_4 = 1;
  88:	f8 01       	movw	r30, r16
  8a:	80 83       	st	Z, r24
  8c:	00 c0       	rjmp	.+0      	; 0x8e <PWM_vidSetPwmDutyCycle+0x8e>
  8e:	0a e4       	ldi	r16, 0x4A	; 74
  90:	10 e0       	ldi	r17, 0x00	; 0

		ICR1_REG = PWM_ICR1_VALUE; //initializing ICR1_VALUE to ICR1 register
  92:	6a 81       	ldd	r22, Y+2	; 0x02
  94:	7b 81       	ldd	r23, Y+3	; 0x03
  96:	8c 81       	ldd	r24, Y+4	; 0x04
  98:	9d 81       	ldd	r25, Y+5	; 0x05
  9a:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
		break;
	}
}
  9e:	dc 01       	movw	r26, r24
  a0:	cb 01       	movw	r24, r22
  a2:	bc 01       	movw	r22, r24
  a4:	cd 01       	movw	r24, r26
  a6:	20 e0       	ldi	r18, 0x00	; 0
  a8:	30 e4       	ldi	r19, 0x40	; 64
  aa:	4c e1       	ldi	r20, 0x1C	; 28
  ac:	55 e4       	ldi	r21, 0x45	; 69
  ae:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  b2:	dc 01       	movw	r26, r24
  b4:	cb 01       	movw	r24, r22
  b6:	bc 01       	movw	r22, r24
  b8:	cd 01       	movw	r24, r26
  ba:	20 e0       	ldi	r18, 0x00	; 0
  bc:	30 e0       	ldi	r19, 0x00	; 0
  be:	48 ec       	ldi	r20, 0xC8	; 200
  c0:	52 e4       	ldi	r21, 0x42	; 66
  c2:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  c6:	dc 01       	movw	r26, r24
  c8:	cb 01       	movw	r24, r22
  ca:	bc 01       	movw	r22, r24
  cc:	cd 01       	movw	r24, r26
  ce:	0e 94 00 00 	call	0	; 0x0 <PWM_vidSetPwmDutyCycle>
  d2:	dc 01       	movw	r26, r24
  d4:	cb 01       	movw	r24, r22
  d6:	f8 01       	movw	r30, r16
  d8:	91 83       	std	Z+1, r25	; 0x01
  da:	80 83       	st	Z, r24
  dc:	27 96       	adiw	r28, 0x07	; 7
  de:	0f b6       	in	r0, 0x3f	; 63
  e0:	f8 94       	cli
  e2:	de bf       	out	0x3e, r29	; 62
  e4:	0f be       	out	0x3f, r0	; 63
  e6:	cd bf       	out	0x3d, r28	; 61
  e8:	cf 91       	pop	r28
  ea:	df 91       	pop	r29
  ec:	1f 91       	pop	r17
  ee:	0f 91       	pop	r16
  f0:	08 95       	ret

Disassembly of section .text.PWM_StartTimer:

00000000 <PWM_StartTimer>:
#include "PWM_int.h"
#include "GPT_int.h"
#include "DIO_int.h"

void PWM_vidPwmInit(u8 Copy_TimerNo)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <PWM_StartTimer+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_TimerNo)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	00 97       	sbiw	r24, 0x00	; 0
  1e:	01 f0       	breq	.+0      	; 0x20 <PWM_StartTimer+0x20>
  20:	2a 81       	ldd	r18, Y+2	; 0x02
  22:	3b 81       	ldd	r19, Y+3	; 0x03
  24:	21 30       	cpi	r18, 0x01	; 1
  26:	31 05       	cpc	r19, r1
  28:	01 f0       	breq	.+0      	; 0x2a <PWM_StartTimer+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <PWM_StartTimer+0x2c>
	{
	case TIMER_0: //if timer 0
		/*initializing timer 0  the same way we used it in GPT*/
		TCCR0_REG.Bits.BIT_3=1;
  2c:	a3 e5       	ldi	r26, 0x53	; 83
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e3 e5       	ldi	r30, 0x53	; 83
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
		TCCR0_REG.Bits.BIT_6=1;
  36:	88 7f       	andi	r24, 0xF8	; 248
  38:	8c 93       	st	X, r24
  3a:	a3 e5       	ldi	r26, 0x53	; 83
  3c:	b0 e0       	ldi	r27, 0x00	; 0
  3e:	e3 e5       	ldi	r30, 0x53	; 83
  40:	f0 e0       	ldi	r31, 0x00	; 0
		break;
	case TIMER_1: //if timer 1
		/*initializing timer 1 changing some bits to match timer 1 */
		TCCR1A_REG.Bits.BIT_7 = 1;
  42:	80 81       	ld	r24, Z
  44:	84 60       	ori	r24, 0x04	; 4
  46:	8c 93       	st	X, r24
  48:	00 c0       	rjmp	.+0      	; 0x4a <PWM_StartTimer+0x4a>
  4a:	ae e4       	ldi	r26, 0x4E	; 78
		TCCR1A_REG.Bits.BIT_6 = 0;
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	ee e4       	ldi	r30, 0x4E	; 78
  50:	f0 e0       	ldi	r31, 0x00	; 0
  52:	80 81       	ld	r24, Z
  54:	88 7f       	andi	r24, 0xF8	; 248
		TCCR1A_REG.Bits.BIT_5 = 0;
  56:	8c 93       	st	X, r24
  58:	ae e4       	ldi	r26, 0x4E	; 78
  5a:	b0 e0       	ldi	r27, 0x00	; 0
  5c:	ee e4       	ldi	r30, 0x4E	; 78
  5e:	f0 e0       	ldi	r31, 0x00	; 0
		TCCR1A_REG.Bits.BIT_4 = 0;
  60:	80 81       	ld	r24, Z
  62:	83 60       	ori	r24, 0x03	; 3
  64:	8c 93       	st	X, r24
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
		/****************************/
		/* selecting fast pwm with ICR1 top*/
		TCCR1A_REG.Bits.BIT_0 = 0;
  6a:	0f 90       	pop	r0
  6c:	cf 91       	pop	r28
  6e:	df 91       	pop	r29
  70:	08 95       	ret

Disassembly of section .text.PWM_StopTimer:

00000000 <PWM_StopTimer>:
#include "PWM_int.h"
#include "GPT_int.h"
#include "DIO_int.h"

void PWM_vidPwmInit(u8 Copy_TimerNo)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <PWM_StopTimer+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_TimerNo)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	00 97       	sbiw	r24, 0x00	; 0
  1e:	01 f0       	breq	.+0      	; 0x20 <PWM_StopTimer+0x20>
  20:	2a 81       	ldd	r18, Y+2	; 0x02
  22:	3b 81       	ldd	r19, Y+3	; 0x03
  24:	21 30       	cpi	r18, 0x01	; 1
  26:	31 05       	cpc	r19, r1
  28:	01 f0       	breq	.+0      	; 0x2a <PWM_StopTimer+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <PWM_StopTimer+0x2c>
	{
	case TIMER_0: //if timer 0
		/*initializing timer 0  the same way we used it in GPT*/
		TCCR0_REG.Bits.BIT_3=1;
  2c:	a3 e5       	ldi	r26, 0x53	; 83
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e3 e5       	ldi	r30, 0x53	; 83
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
		TCCR0_REG.Bits.BIT_6=1;
  36:	88 7f       	andi	r24, 0xF8	; 248
  38:	8c 93       	st	X, r24
  3a:	00 c0       	rjmp	.+0      	; 0x3c <PWM_StopTimer+0x3c>
  3c:	ae e4       	ldi	r26, 0x4E	; 78
  3e:	b0 e0       	ldi	r27, 0x00	; 0
  40:	ee e4       	ldi	r30, 0x4E	; 78
		break;
	case TIMER_1: //if timer 1
		/*initializing timer 1 changing some bits to match timer 1 */
		TCCR1A_REG.Bits.BIT_7 = 1;
  42:	f0 e0       	ldi	r31, 0x00	; 0
  44:	80 81       	ld	r24, Z
  46:	88 7f       	andi	r24, 0xF8	; 248
  48:	8c 93       	st	X, r24
  4a:	0f 90       	pop	r0
		TCCR1A_REG.Bits.BIT_6 = 0;
  4c:	0f 90       	pop	r0
  4e:	0f 90       	pop	r0
  50:	cf 91       	pop	r28
  52:	df 91       	pop	r29
  54:	08 95       	ret

main.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000002b8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000003ff  00000000  00000000  000002ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.main    000001a6  00000000  00000000  000006eb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.main:

00000000 <main>:
#include "DIO_int.h"
#include "LCD_int.h"
#include "PWM_int.h"

int main()
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <main+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <main+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
	LCD_vidInit();
   e:	0e 94 00 00 	call	0	; 0x0 <main>
	ADC_vidInit();
  12:	0e 94 00 00 	call	0	; 0x0 <main>
	DIO_vidSetPinDirection(PORTD_REG,DIO_u8PIN_5,DIO_u8OUTPUT);
  16:	e2 e3       	ldi	r30, 0x32	; 50
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	65 e0       	ldi	r22, 0x05	; 5
  1e:	41 e0       	ldi	r20, 0x01	; 1
  20:	0e 94 00 00 	call	0	; 0x0 <main>
	PWM_vidPwmInit(TIMER_1);
  24:	81 e0       	ldi	r24, 0x01	; 1
  26:	0e 94 00 00 	call	0	; 0x0 <main>
	u16 Analog_Value;
	u16 update;
	u8 angleDegree;
	PWM_StartTimer(TIMER_1);
  2a:	81 e0       	ldi	r24, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <main>
	while(1)
	{
		Analog_Value=ADC_u16Read(ADC_ACDMUX_CHANNEL_ADC0 );
  30:	80 e0       	ldi	r24, 0x00	; 0
  32:	90 e0       	ldi	r25, 0x00	; 0
  34:	0e 94 00 00 	call	0	; 0x0 <main>
  38:	9d 83       	std	Y+5, r25	; 0x05
  3a:	8c 83       	std	Y+4, r24	; 0x04
		Analog_Value=(u16)(((u32)Analog_Value*5000)/1024);
  3c:	8c 81       	ldd	r24, Y+4	; 0x04
  3e:	9d 81       	ldd	r25, Y+5	; 0x05
  40:	cc 01       	movw	r24, r24
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	28 e8       	ldi	r18, 0x88	; 136
  48:	33 e1       	ldi	r19, 0x13	; 19
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	50 e0       	ldi	r21, 0x00	; 0
  4e:	bc 01       	movw	r22, r24
  50:	cd 01       	movw	r24, r26
  52:	0e 94 00 00 	call	0	; 0x0 <main>
  56:	dc 01       	movw	r26, r24
  58:	cb 01       	movw	r24, r22
  5a:	07 2e       	mov	r0, r23
  5c:	7a e0       	ldi	r23, 0x0A	; 10
  5e:	b6 95       	lsr	r27
  60:	a7 95       	ror	r26
  62:	97 95       	ror	r25
  64:	87 95       	ror	r24
  66:	7a 95       	dec	r23
  68:	01 f4       	brne	.+0      	; 0x6a <main+0x6a>
  6a:	70 2d       	mov	r23, r0
  6c:	9d 83       	std	Y+5, r25	; 0x05
  6e:	8c 83       	std	Y+4, r24	; 0x04
		angleDegree=(u8)(((u32)Analog_Value*180)/5000);
  70:	8c 81       	ldd	r24, Y+4	; 0x04
  72:	9d 81       	ldd	r25, Y+5	; 0x05
  74:	cc 01       	movw	r24, r24
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b0 e0       	ldi	r27, 0x00	; 0
  7a:	24 eb       	ldi	r18, 0xB4	; 180
  7c:	30 e0       	ldi	r19, 0x00	; 0
  7e:	40 e0       	ldi	r20, 0x00	; 0
  80:	50 e0       	ldi	r21, 0x00	; 0
  82:	bc 01       	movw	r22, r24
  84:	cd 01       	movw	r24, r26
  86:	0e 94 00 00 	call	0	; 0x0 <main>
  8a:	dc 01       	movw	r26, r24
  8c:	cb 01       	movw	r24, r22
  8e:	28 e8       	ldi	r18, 0x88	; 136
  90:	33 e1       	ldi	r19, 0x13	; 19
  92:	40 e0       	ldi	r20, 0x00	; 0
  94:	50 e0       	ldi	r21, 0x00	; 0
  96:	bc 01       	movw	r22, r24
  98:	cd 01       	movw	r24, r26
  9a:	0e 94 00 00 	call	0	; 0x0 <main>
  9e:	da 01       	movw	r26, r20
  a0:	c9 01       	movw	r24, r18
  a2:	89 83       	std	Y+1, r24	; 0x01
		PWM_vidSetPwmDutyCycle(TIMER_1,(f32)Analog_Value/1000+5);
  a4:	8c 81       	ldd	r24, Y+4	; 0x04
  a6:	9d 81       	ldd	r25, Y+5	; 0x05
  a8:	cc 01       	movw	r24, r24
  aa:	a0 e0       	ldi	r26, 0x00	; 0
  ac:	b0 e0       	ldi	r27, 0x00	; 0
  ae:	bc 01       	movw	r22, r24
  b0:	cd 01       	movw	r24, r26
  b2:	0e 94 00 00 	call	0	; 0x0 <main>
  b6:	dc 01       	movw	r26, r24
  b8:	cb 01       	movw	r24, r22
  ba:	bc 01       	movw	r22, r24
  bc:	cd 01       	movw	r24, r26
  be:	20 e0       	ldi	r18, 0x00	; 0
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	4a e7       	ldi	r20, 0x7A	; 122
  c4:	54 e4       	ldi	r21, 0x44	; 68
  c6:	0e 94 00 00 	call	0	; 0x0 <main>
  ca:	dc 01       	movw	r26, r24
  cc:	cb 01       	movw	r24, r22
  ce:	bc 01       	movw	r22, r24
  d0:	cd 01       	movw	r24, r26
  d2:	20 e0       	ldi	r18, 0x00	; 0
  d4:	30 e0       	ldi	r19, 0x00	; 0
  d6:	40 ea       	ldi	r20, 0xA0	; 160
  d8:	50 e4       	ldi	r21, 0x40	; 64
  da:	0e 94 00 00 	call	0	; 0x0 <main>
  de:	dc 01       	movw	r26, r24
  e0:	cb 01       	movw	r24, r22
  e2:	bc 01       	movw	r22, r24
  e4:	cd 01       	movw	r24, r26
  e6:	0e 94 00 00 	call	0	; 0x0 <main>
  ea:	9b 01       	movw	r18, r22
  ec:	ac 01       	movw	r20, r24
  ee:	81 e0       	ldi	r24, 0x01	; 1
  f0:	ba 01       	movw	r22, r20
  f2:	a9 01       	movw	r20, r18
  f4:	0e 94 00 00 	call	0	; 0x0 <main>
		if (update!=Analog_Value)
  f8:	2a 81       	ldd	r18, Y+2	; 0x02
  fa:	3b 81       	ldd	r19, Y+3	; 0x03
  fc:	8c 81       	ldd	r24, Y+4	; 0x04
  fe:	9d 81       	ldd	r25, Y+5	; 0x05
 100:	28 17       	cp	r18, r24
 102:	39 07       	cpc	r19, r25
 104:	01 f4       	brne	.+0      	; 0x106 <main+0x106>
 106:	00 c0       	rjmp	.+0      	; 0x108 <main+0x108>
		{
			LCD_vidSendCommand(LCD_u8CLEAR_DISPLAY);
 108:	81 e0       	ldi	r24, 0x01	; 1
 10a:	0e 94 00 00 	call	0	; 0x0 <main>
			if ((angleDegree/100)%10)
 10e:	89 81       	ldd	r24, Y+1	; 0x01
 110:	94 e6       	ldi	r25, 0x64	; 100
 112:	69 2f       	mov	r22, r25
 114:	0e 94 00 00 	call	0	; 0x0 <main>
 118:	9a e0       	ldi	r25, 0x0A	; 10
 11a:	69 2f       	mov	r22, r25
 11c:	0e 94 00 00 	call	0	; 0x0 <main>
 120:	89 2f       	mov	r24, r25
 122:	88 23       	and	r24, r24
 124:	01 f0       	breq	.+0      	; 0x126 <main+0x126>
				LCD_vidWriteData((angleDegree/100)%10+'0');
 126:	89 81       	ldd	r24, Y+1	; 0x01
 128:	94 e6       	ldi	r25, 0x64	; 100
 12a:	69 2f       	mov	r22, r25
 12c:	0e 94 00 00 	call	0	; 0x0 <main>
 130:	9a e0       	ldi	r25, 0x0A	; 10
 132:	69 2f       	mov	r22, r25
 134:	0e 94 00 00 	call	0	; 0x0 <main>
 138:	89 2f       	mov	r24, r25
 13a:	80 5d       	subi	r24, 0xD0	; 208
 13c:	0e 94 00 00 	call	0	; 0x0 <main>
			if ((angleDegree/10)%10 || (angleDegree/100)%10)
 140:	89 81       	ldd	r24, Y+1	; 0x01
 142:	9a e0       	ldi	r25, 0x0A	; 10
 144:	69 2f       	mov	r22, r25
 146:	0e 94 00 00 	call	0	; 0x0 <main>
 14a:	9a e0       	ldi	r25, 0x0A	; 10
 14c:	69 2f       	mov	r22, r25
 14e:	0e 94 00 00 	call	0	; 0x0 <main>
 152:	89 2f       	mov	r24, r25
 154:	88 23       	and	r24, r24
 156:	01 f4       	brne	.+0      	; 0x158 <main+0x158>
 158:	89 81       	ldd	r24, Y+1	; 0x01
 15a:	94 e6       	ldi	r25, 0x64	; 100
 15c:	69 2f       	mov	r22, r25
 15e:	0e 94 00 00 	call	0	; 0x0 <main>
 162:	9a e0       	ldi	r25, 0x0A	; 10
 164:	69 2f       	mov	r22, r25
 166:	0e 94 00 00 	call	0	; 0x0 <main>
 16a:	89 2f       	mov	r24, r25
 16c:	88 23       	and	r24, r24
 16e:	01 f0       	breq	.+0      	; 0x170 <main+0x170>
				LCD_vidWriteData((angleDegree/10)%10+'0');
 170:	89 81       	ldd	r24, Y+1	; 0x01
 172:	9a e0       	ldi	r25, 0x0A	; 10
 174:	69 2f       	mov	r22, r25
 176:	0e 94 00 00 	call	0	; 0x0 <main>
 17a:	9a e0       	ldi	r25, 0x0A	; 10
 17c:	69 2f       	mov	r22, r25
 17e:	0e 94 00 00 	call	0	; 0x0 <main>
 182:	89 2f       	mov	r24, r25
 184:	80 5d       	subi	r24, 0xD0	; 208
 186:	0e 94 00 00 	call	0	; 0x0 <main>
			LCD_vidWriteData(angleDegree%10+'0');
 18a:	89 81       	ldd	r24, Y+1	; 0x01
 18c:	9a e0       	ldi	r25, 0x0A	; 10
 18e:	69 2f       	mov	r22, r25
 190:	0e 94 00 00 	call	0	; 0x0 <main>
 194:	89 2f       	mov	r24, r25
 196:	80 5d       	subi	r24, 0xD0	; 208
 198:	0e 94 00 00 	call	0	; 0x0 <main>
			update=Analog_Value;
 19c:	8c 81       	ldd	r24, Y+4	; 0x04
 19e:	9d 81       	ldd	r25, Y+5	; 0x05
 1a0:	9b 83       	std	Y+3, r25	; 0x03
 1a2:	8a 83       	std	Y+2, r24	; 0x02
 1a4:	00 c0       	rjmp	.+0      	; 0x1a6 <__SREG__+0x167>
